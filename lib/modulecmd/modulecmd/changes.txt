import json
import zlib
import base64
from textwrap import wrap
import modulecmd.config


def serialize(obj):
    return _encode(json.dumps(obj))


def deserialize(serialized):
    string = _decode(serialized)
    return json.loads(string)


def serialize_chunked(raw):
    serialized = serialize(raw)
    chunk_size = modulecmd.config.get("serialize_chunk_size")
    if chunk_size < 0:
        return [serialized]
    return wrap(serialized, chunk_size)


def deserialize_chunked(serialized_chunks):
    return deserialize("".join(serialized_chunks))


def _encode(item):
    encoded = str(item).encode("utf-8")
    compress = modulecmd.config.get("compress_serialized_variables")
    if compress:
        encoded = zlib.compress(encoded)
    return base64.urlsafe_b64encode(encoded).decode()


def _decode(item):
    encoded = base64.urlsafe_b64decode(str(item))
    compress = modulecmd.config.get("compress_serialized_variables")
    if compress:
        encoded = zlib.decompress(encoded)
    return encoded.decode()
import os
import sys
import modulecmd.config
import modulecmd.names
import modulecmd.paths
from llnl.util.lang import load_module_from_file, Singleton


class UserEnv:
    def __init__(self, filename):
        # Load user module, if found
        if filename is None:
            self._module = None
            self._modulename = None
        else:
            modulename = "modulecmd._{0}".format(
                os.path.splitext(os.path.basename(filename))[0]
            )
            self._module = load_module_from_file(modulename, filename)
            assert self._module is not None
            self._modulename = modulename

    def __getattr__(self, attr):
        if self._module is None:  # pragma: no cover
            return None
        return getattr(self._module, attr)


def factory():
    basename = modulecmd.names.user_env_file_basename
    f = modulecmd.paths.join_user(basename)
    filename = f if os.path.isfile(f) else None
    return UserEnv(filename)


def set_user_env(user_env):
    global env
    assert isinstance(user_env, UserEnv)
    env = user_env


def reset():  # pragma: no cover
    global env
    if env._modulename in sys.modules:
        del sys.modules[env._modulename]
    env = factory()


env = Singleton(factory)
import os
import sys

import llnl.util.tty as tty
import modulecmd.alias
import modulecmd.callback
import modulecmd.clone
import modulecmd.collection
import modulecmd.config
import modulecmd.environ
import modulecmd.error
import modulecmd.modes
import modulecmd.module
import modulecmd.modulepath
import modulecmd.names
import modulecmd.paths
import modulecmd.shell
import modulecmd.user
from llnl.util.filesystem import working_dir
from llnl.util.lang import Singleton
from llnl.util.tty import terminal_size
from llnl.util.tty.colify import colified
from llnl.util.tty.color import colorize
from modulecmd.error import (
    FamilyLoadedError,
    ModuleConflictError,
    ModuleLoadError,
    ModuleNotFoundError,
    ModuleNotLoadedError,
    PrereqMissingError,
)
from modulecmd.util.lang import split
from modulecmd.util.tty import grep_pat_in_string
from modulecmd.util.tty.pager import pager
from six import StringIO, exec_


class system_state:
    def __init__(self):
        self.cur_module_command_his = StringIO()
        self._loaded_modules = None
        self._initial_loaded_modules = None
        self._swapped_explicitly = []
        self._swapped_on_version_change = []
        self._swapped_on_family_update = []
        self._swapped_on_mp_change = []
        self._unloaded_on_mp_change = []

    def module_is_loaded(self, key):
        if isinstance(key, modulecmd.module.Module):
            return key in self.loaded_modules
        elif os.path.isfile(key):
            return key in [m.filename for m in self.loaded_modules]
        else:
            for module in self.loaded_modules:
                if module.name == key or module.fullname == key:
                    return True
        return False

    @property
    def loaded_modules(self):
        if self._loaded_modules is None:
            tty.debug("Reading loaded modules")
            self._loaded_modules = []
            lm_cellar = modulecmd.environ.get(
                modulecmd.names.loaded_module_cellar, default=[], serialized=True
            )
            for ar in lm_cellar:
                module = unarchive_module(ar)
                self._loaded_modules.append(module)
            self._initial_loaded_modules = [m.fullname for m in self._loaded_modules]
        # return copy so that no one else can modify the loaded modules
        return list(self._loaded_modules)

    @loaded_modules.setter
    def loaded_modules(self, modules):
        """Set environment variables for loaded module names and files"""
        self._loaded_modules = modules

        assert all([m.acquired_as is not None for m in self._loaded_modules])
        lm = [archive_module(m) for m in self._loaded_modules]
        modulecmd.environ.set(modulecmd.names.loaded_module_cellar, lm, serialize=True)

        # The following are for compatibility with other module programs
        lm_names = [m.fullname for m in self._loaded_modules]
        modulecmd.environ.set_path(modulecmd.names.loaded_modules, lm_names)

        lm_files = [m.filename for m in self._loaded_modules]
        modulecmd.environ.set_path(modulecmd.names.loaded_module_files, lm_files)

    def register_module(self, module):
        """Register the `module` to the list of loaded modules"""
        # Update the environment
        if not modulecmd.modulepath.contains(module.modulepath):
            raise modulecmd.error.InconsistentModuleStateError(module)
        if modulecmd.config.get("skip_add_devpack") and module.name.startswith(
            ("sems-devpack", "devpack")
        ):
            return
        if module not in self.loaded_modules:
            module.refcount += 1
            self._loaded_modules.append(module)
        else:
            raise ModuleRegisteredError(module)

    def unregister_module(self, module):
        """Unregister the `module` to the list of loaded modules"""
        # Don't use `self.loaded_modules` because the module we are unregistering
        # may no longer be available. `self.loaded_modules` makes some assumptions
        # that can be violated in certain situations. Like, for example, # when
        # "unusing" a directory on the MODULEPATH which has loaded modules.
        # Those modules are automaically unloaded since they are no longer
        # available.
        for (i, loaded) in enumerate(self.loaded_modules):
            if loaded.filename == module.filename:
                break
        else:
            raise ModuleNotRegisteredError(module)
        module.refcount = 0
        self._loaded_modules.pop(i)

    def swapped_explicitly(self, old, new):
        self._swapped_explicitly.append((old, new))

    def swapped_on_version_change(self, old, new):
        self._swapped_on_version_change.append((old, new))

    def swapped_on_mp_change(self, old, new):
        self._swapped_on_mp_change.append((old, new))

    def unloaded_on_mp_change(self, old):
        self._unloaded_on_mp_change.append(old)

    def swapped_on_family_update(self, old, new):
        self._swapped_on_family_update.append((old, new))

    def format_changes(self, file=None):
        file = file or StringIO()
        self.format_loaded(file=file)
        self.format_swapped(file=file)
        self.format_updated_f(file=file)
        self.format_updated_v(file=file)
        self.format_unloaded_mp(file=file)
        self.format_updated_mp(file=file)

    def format_loaded(self, file=None):
        file = file or StringIO()
        if self._loaded_modules is not None and modulecmd.config.get("verbose"):
            new_modules = [
                m
                for m in self._loaded_modules
                if m.fullname not in self._initial_loaded_modules
            ]
            if new_modules:
                file.write("The following modules were @G{loaded}\n")
                for (i, m) in enumerate(new_modules):
                    file.write("  {0}) {1}\n".format(i + 1, m.fullname))
                file.write("\n")

    def format_swapped(self, file=None):
        file = file or StringIO()
        # Report swapped
        if self._swapped_explicitly:
            file.write("The following modules have been @G{swapped}\n")
            for (i, (m1, m2)) in enumerate(self._swapped_explicitly):
                a, b = m1.fullname, m2.fullname
                file.write("  {0}) {1} => {2}\n".format(i + 1, a, b))
            file.write("\n")

    def format_updated_f(self, file=None):
        file = file or StringIO()
        # Report reloaded
        if self._swapped_on_family_update:  # pragma: no cover
            file.write(
                "The following modules in the same family have "
                "been @G{updated with a version change}\n"
            )
            for (i, (m1, m2)) in enumerate(self._swapped_on_family_update):
                a, b, fam = m1.fullname, m2.fullname, m1.family
                file.write("  {0}) {1} => {2} ({3})\n".format(i + 1, a, b, fam))
            file.write("\n")

    def format_updated_v(self, file=None):
        file = file or StringIO()
        if self._swapped_on_version_change:
            file.write(
                "The following modules have been @G{updated with a version change}\n"
            )
            for (i, (m1, m2)) in enumerate(self._swapped_on_version_change):
                a, b = m1.fullname, m2.fullname
                file.write("  {0}) {1} => {2}\n".format(i + 1, a, b))
            file.write("\n")

    def format_unloaded_mp(self, file=None):
        file = file or StringIO()
        # Report changes due to to change in modulepath
        if self._unloaded_on_mp_change:  # pragma: no cover
            lm_files = [_.filename for _ in self.loaded_modules]
            unloaded = [
                _ for _ in self._unloaded_on_mp_change if _.filename not in lm_files
            ]
            file.write(
                "The following modules have been @G{unloaded with a MODULEPATH change}\n"
            )
            for (i, m) in enumerate(unloaded):
                file.write("  {0}) {1}\n".format(i + 1, m.fullname))
            file.write("\n")

    def format_updated_mp(self, file=None):
        file = file or StringIO()
        debug_mode = modulecmd.config.get("debug")
        if self._swapped_on_mp_change:
            file.write(
                "The following modules have been @G{updated with a MODULEPATH change}\n"
            )
            for (i, (m1, m2)) in enumerate(self._swapped_on_mp_change):
                a, b = m1.fullname, m2.fullname
                if debug_mode:  # pragma: no cover
                    n = len("  {0}) ".format(i + 1))
                    a += " ({0})".format(m1.modulepath)
                    b = "\n" + " " * n + b + " ({0})".format(m2.modulepath)
                file.write("  {0}) {1} => {2}\n".format(i + 1, a, b))
            file.write("\n")

        return


state = system_state()


def module_is_loaded(key):
    return state.module_is_loaded(key)


def loaded_modules():
    return state.loaded_modules


def register_module(module):
    return state.register_module(module)


def unregister_module(module):
    return state.unregister_module(module)


def unarchive_module(ar):
    path = ar.get("modulepath")
    if path and not modulecmd.modulepath.contains(path):  # pragma: no cover
        use(path)
    module = modulecmd.modulepath.get(ar["filename"])
    if module is None:
        raise modulecmd.error.ModuleNotFoundError(ar["fullname"])
    assert module.fullname == ar["fullname"]
    module.family = ar["family"]
    module.opts = ar["opts"]
    module.acquired_as = ar["acquired_as"]
    module.refcount = ar["refcount"]
    return module


def avail(terse=False, regex=None, show_all=False, long_format=False):
    avail = modulecmd.modulepath.avail(terse=terse, regex=regex, long_format=long_format)
    if show_all:
        avail += modulecmd.collection.avail(terse=terse, regex=regex)
        avail += modulecmd.clone.avail(terse=terse)
    return avail


def save_clone(name):
    return modulecmd.clone.save(name)


def restore_clone(name):
    the_clone = modulecmd.clone.get(name)
    if the_clone is None:
        raise modulecmd.error.CloneDoesNotExistError(name)
    restore_clone_impl(the_clone)


def remove_clone(name):
    return modulecmd.clone.remove(name)


def restore_clone_impl(the_clone):
    # Purge current environment
    purge(load_after_purge=False)

    mp = the_clone.pop(modulecmd.names.modulepath, None)
    current_env = modulecmd.environ.copy(include_os=True)
    for (key, val) in current_env.items():
        if key == modulecmd.names.modulepath:
            continue
        modulecmd.environ.unset(key)

    path = modulecmd.modulepath.Modulepath(split(mp, os.pathsep))
    modulecmd.modulepath.set_path(path)

    # Make sure environment matches clone
    for (key, val) in the_clone.items():
        modulecmd.environ.set(key, val)

    # Load modules to make sure aliases/functions are restored
    lm_cellar = modulecmd.environ._get_and_deserialize(
        the_clone, modulecmd.names.loaded_module_cellar
    )
    if lm_cellar:
        loaded_modules = []
        for ar in lm_cellar:
            try:
                module = unarchive_module(ar)
            except modulecmd.error.ModuleNotFoundError:
                raise modulecmd.error.CloneModuleNotFoundError(
                    ar["fullname"], ar["filename"]
                )
            loaded_modules.append(module)
        state.loaded_modules = loaded_modules

        for module in loaded_modules:
            load_partial(module)


def save_collection(name):
    """Save currently loaded modules to a collection"""
    modulecmd.collection.save(name, state.loaded_modules)


def show_collection(name):
    """Save the collection `name`"""
    s = modulecmd.collection.show(name)
    sys.stderr.write(s + "\n")
    return 0


def restore_collection(name):
    """Restore a collection of modules previously saved"""
    the_collection = modulecmd.collection.get(name)
    if the_collection is None:
        raise modulecmd.error.CollectionNotFoundError(name)
    return restore_collection_impl(name, the_collection)


def remove_collection(name):
    """Delete collection `name` from database"""
    modulecmd.collection.remove(name)


def pop_from_loaded_collection(name):
    """Remove module `name` from currently loaded collection"""
    modulecmd.collection.pop_from_loaded_collection(name)


def add_to_loaded_collection(name):
    """Append module `name` to currently loaded collection"""
    modulecmd.collection.add_to_loaded_collection(name)


def restore_collection_impl(name, the_collection):
    # First unload all loaded modules
    modulecmd.environ.unset(modulecmd.names.loaded_collection)
    purge(load_after_purge=False)

    # clear the modulepath
    orig_path = modulecmd.modulepath.path()
    path = modulecmd.modulepath.Modulepath([])
    modulecmd.modulepath.set_path(path)

    # Now load the collection, one module at a time
    for (directory, archives) in the_collection:
        use(directory, append=True)
        for ar in archives:
            try:
                module = unarchive_module(ar)
                tty.verbose("Loading part of collection: {0}".format(module))
            except modulecmd.error.ModuleNotFoundError:
                raise modulecmd.error.CollectionModuleNotFoundError(
                    ar["fullname"], ar["filename"]
                )
            load_impl(module)
            module.acquired_as = module.fullname
            assert module.is_loaded
    modulecmd.environ.set(modulecmd.names.loaded_collection, name)
    for p in orig_path:
        if not modulecmd.modulepath.contains(p):  # pragma: no cover
            use(p, append=True)
    return None


def conflict(module, *conflicting):
    """The module we are trying to load, `module` conflicts with the module
    given by `conflicting_module`"""
    loaded_modules = state.loaded_modules
    lm_names = list(set([x for m in loaded_modules for x in [m.name, m.fullname]]))
    for other in conflicting:
        if other in lm_names:
            if modulecmd.config.get("resolve_conflicts"):
                # Unload the conflicting module
                unload(other)
            else:
                raise ModuleConflictError(other, module.name)


def get_entity_text(name):
    module = modulecmd.modulepath.get(name)
    if module is not None:
        return open(module.filename).read()
    elif modulecmd.collection.contains(name):
        return str(modulecmd.collection.get(name))
    raise modulecmd.error.EntityNotFoundError(name)


def more(name):
    pager(get_entity_text(name))


def cat(name):
    pager(get_entity_text(name), plain=True)


def format_output():  # pragma: no cover
    """Format the final output for the shell to be evaluated"""
    output = modulecmd.environ.format_output()
    return output


def dump(stream=None):  # pragma: no cover
    """Dump the final results to the shell to be evaluated"""
    output = format_output()
    stream = sys.stderr if modulecmd.config.get("dryrun") else stream or sys.stdout
    stream.write(output)

    output = state.format_changes()
    if output.split():
        sys.stderr.write(colorize(output))


# ----------------------------- MODULE EXECUTION FUNCTIONS
def execmodule(module, mode):
    """Execute the module in a sandbox"""
    assert module.acquired_as is not None
    modulecmd.modes.assert_known_mode(mode)

    # Enable logging of commands in this module
    state.cur_module_command_his = StringIO()

    try:
        return execmodule_in_sandbox(module, mode)

    except FamilyLoadedError as e:
        # Module of same family already loaded, unload it first

        # This comes after first trying to load the module because the
        # family is set within the module, so the module must first be
        # loaded to determine the family. If when the family is being set
        # it is discovered that a module from the same family is loaded,
        # the FamilyLoadedError is raised.

        # This should only happen in load mode
        assert mode == modulecmd.modes.load
        other = modulecmd.modulepath.get(e.args[0])
        state.swapped_on_family_update(other, module)
        assert other.is_loaded
        swap_impl(other, module)


def execmodule_in_sandbox(module, mode):
    """Execute python module in sandbox"""

    # Execute the environment
    tty.debug("Executing module {0} with mode {1}".format(module, mode))
    module.prepare()
    ns = module_exec_sandbox(module, mode)
    code = compile(module.read(mode), module.filename, "exec")
    with working_dir(os.path.dirname(module.filename)):
        try:
            if isinstance(module, modulecmd.module.TclModule):
                clone = modulecmd.environ.clone()
            exec_(code, ns, {})
        except modulecmd.error.StopLoadingModuleError:
            pass
        except modulecmd.error.TclModuleBreakError:
            # `break` command encountered.  we need to roll back changes to the
            # environment and tell whoever called not to register this module
            modulecmd.environ.restore(clone)
            module.exec_failed_do_not_register = True


def module_exec_sandbox(module, mode):
    callback = lambda cb, **kwds: modulecmd.callback.callback(cb, module, mode, **kwds)
    ns = {
        "os": os,
        "sys": sys,
        "env": modulecmd.environ.copy(include_os=True),
        "self": module,
        "user_env": modulecmd.user.env,
        "is_darwin": "darwin" in sys.platform,
        "IS_DARWIN": "darwin" in sys.platform,
        #
        "add_option": module.add_option,
        "opts": Singleton(module.parse_opts),
    }

    for fun in modulecmd.callback.all_callbacks():
        kwds = {}
        if fun.endswith(("set_alias", "set_shell_function", "getenv")):
            # when='always' because we may partially load a module just define
            # aliases and functions.  This is used by the clone capability that
            # can set environment variables from a clone, but cannot know what
            # aliases and functions existed in the clone.
            kwds["when"] = "always"
        elif fun == "whatis":
            # filter out this function if not in whatis mode
            kwds["when"] = mode == modulecmd.modes.whatis
        elif fun == "help":
            # filter out this function if not in help mode
            kwds["when"] = mode == modulecmd.modes.help
        else:
            # Let the function know nothing was explicitly set
            kwds["when"] = None
        ns[fun] = callback(fun, **kwds)
    return ns


def family(module, mode, family_name):
    """Assign a family"""

    name = module.name
    version = module.version.string
    module.family = family_name

    def family_envar_keys():
        fam_key = modulecmd.names.family_name(family_name)
        ver_key = modulecmd.names.family_version(family_name)
        return (fam_key, ver_key)

    if mode == modulecmd.modes.unload:
        fam_key, ver_key = family_envar_keys()
        modulecmd.environ.unset(fam_key)
        modulecmd.environ.unset(ver_key)

    else:
        fam_key, ver_key = family_envar_keys()
        fam = modulecmd.environ.get(fam_key)
        if fam is not None:
            # Attempting to load module of same family
            ver = modulecmd.environ.get(ver_key)
            other = fam if ver in ("false", None) else os.path.join(fam, ver)
            raise FamilyLoadedError(other)

        modulecmd.environ.set(fam_key, name)
        ver = "false" if not version else version
        modulecmd.environ.set(ver_key, ver)


def find(names):
    for name in names:
        s = None
        candidates = modulecmd.modulepath.candidates(name)
        if not candidates:
            raise ModuleNotFoundError(name)
        for module in candidates:
            s = "@*{%s}\n  @C{%s}" % (module.fullname, module.filename)
            sys.stderr.write(colorize(s) + "\n")


def help(modulename):
    """Display 'help' message for the module given by `modulename`"""
    module = modulecmd.modulepath.get(modulename)
    if module is None:
        raise ModuleNotFoundError(modulename, mp=modulecmd.modulepath)
    load_partial(module, mode=modulecmd.modes.help)
    return module.format_help()


def info(names):
    for name in names:
        modules = modulecmd.modulepath.candidates(name)
        if not modules:
            raise ModuleNotFoundError(name)

        for module in modules:
            s = "@B{Module:} @*{%s}\n" % module.fullname
            s += "  @C{Name:}         %s\n" % module.name

            if module.version:  # pragma: no cover
                s += "  @C{Version:}      %s\n" % module.version

            if module.family:  # pragma: no cover
                s += "  @C{Family:}      %s\n" % module.family

            s += "  @C{Loaded:}       %s\n" % module.is_loaded
            s += "  @C{Filename:}     %s\n" % module.filename
            s += "  @C{Modulepath:}   %s" % module.modulepath

            unlocked_by = module.unlocked_by()
            if unlocked_by:  # pragma: no cover
                s += "  @C{Unlocked by:}  %s\n"
                for m in unlocked_by:
                    s += "                    %s\n" % m.fullname

            unlocks = module.unlocks()
            if unlocks:  # pragma: no cover
                s += "  @C{Unlocks:}      %s\n"
                for dirname in unlocks:
                    s += "                    %s\n" % dirname

            sys.stderr.write(colorize(s) + "\n")


def init(dirnames):
    initial_env = modulecmd.environ.copy(include_os=True)
    if modulecmd.collection.contains(
        modulecmd.names.default_user_collection
    ):  # pragma: no cover
        restore_collection(modulecmd.names.default_user_collection)
    for dirname in dirnames:
        use(dirname, append=True)
    modulecmd.environ.set(modulecmd.names.initial_env, initial_env, serialize=True)
    return


def list(terse=False, show_command=False, regex=None):
    Namespace = modulecmd.module.Namespace
    if not state.loaded_modules:
        return "No loaded modules\n"

    sio = StringIO()
    loaded_module_names = []
    for loaded in state.loaded_modules:
        fullname = loaded.fullname
        if loaded.opts:
            fullname += " " + Namespace(**(loaded.opts)).joined(" ")
        loaded_module_names.append(fullname)

    if terse:
        sio.write("\n".join(loaded_module_names))
    elif show_command:
        for module in loaded_module_names:
            sio.write("module load {0}\n".format(module))
    else:
        sio.write("Currently loaded modules\n")
        loaded = [
            "{0}) {1}".format(i + 1, m) for (i, m) in enumerate(loaded_module_names)
        ]
        _, width = terminal_size()
        sio.write(colified(loaded, indent=4, width=max(100, width)))

    s = sio.getvalue()
    if regex:
        s = grep_pat_in_string(s, regex, color="G")

    return s


def load(name, opts=None, insert_at=None, caller="command_line"):
    """Load the module given by `name`

    This is a higher level interface to `load_impl` that gets the actual module
    object from `name`

    Parameters
    ----------
    name : string_like
        Module name, full name, or file path
    opts : dict
        (Optional) options to send to module
    insert_at : int
        Load the module as the `insert_at`th module.
    caller : str
        Who is calling. If modulefile, the reference count will be incremented
        if the module is already loaded.

    Returns
    -------
    module : Module
        If the `name` was loaded (or is already loaded), return its module.

    Raises
    ------
    ModuleNotFoundError

    """
    tty.verbose("Loading {0}".format(name))

    # Execute the module
    module = modulecmd.modulepath.get(
        name, use_file_modulepath=True
    )  # caller=="command_line")
    if module is None:
        if caller == "command_line":
            collection = modulecmd.collection.get(name)
            if collection is not None:
                return restore_collection_impl(name, collection)
        raise ModuleNotFoundError(name, mp=modulecmd.modulepath)

    # Set the command line options
    if opts:
        module.opts = opts

    if module.is_loaded:
        if caller == "modulefile":
            module.refcount += 1
        else:
            tty.warn(
                "{0} is already loaded, use 'module reload' to reload".format(
                    module.fullname
                )
            )
        return module

    if modulecmd.environ.get(modulecmd.names.loaded_collection):  # pragma: no cover
        collection = modulecmd.environ.get(modulecmd.names.loaded_collection)
        tty.debug(
            "Loading {0} on top of loaded collection {1}. "
            "Removing the collection name from the environment".format(
                module.fullname, collection
            )
        )
        modulecmd.environ.unset(modulecmd.names.loaded_collection)

    if insert_at is not None:
        load_inserted_impl(module, insert_at)
    else:
        load_impl(module)

    return module


def load_impl(module):
    """Implementation of load.

    Parameters
    ----------
    module : Module
        The module to load

    """

    # See if a module of the same name is already loaded. If so, swap that
    # module with the requested module
    for other in state.loaded_modules:
        if other.name == module.name:
            swap_impl(other, module)
            state.swapped_on_version_change(other, module)
            return

    # Now load it
    execmodule(module, modulecmd.modes.load)

    if getattr(module, "exec_failed_do_not_register", False):
        # Something happened during the execution of this module and we are not
        # to register it.
        pass
    elif module.refcount != 0:
        # Nonzero reference count means the module load was completed by
        # someone else. This can only happen in the case of loading a module of
        # the same family. In that case, execmodule catches a FamilyLoadedError
        # exception and swaps this module with the module of the same family.
        # The swap completes the load.
        if not (
            state._swapped_on_family_update
            and module == state._swapped_on_family_update[-1][1]
        ):  # pragma: no cover
            raise ModuleLoadError("Expected 0 refcount")
    else:
        state.register_module(module)

    return


def load_inserted_impl(module, insert_at):
    """Load the `module` at `insert_at` by unloading all modules beyond
    `insert_at`, loading `module`, then reloading the unloaded modules"""

    insertion_loc = insert_at - 1
    to_unload_and_reload = state.loaded_modules[insertion_loc:]
    opts = [m.opts for m in to_unload_and_reload]
    for other in to_unload_and_reload[::-1]:
        unload_impl(other)

    load_impl(module)

    # Reload any that need to be unloaded first
    for (i, other) in enumerate(to_unload_and_reload):
        assert not other.is_loaded
        other_module = modulecmd.modulepath.get(other.acquired_as)
        if other_module is None:
            # The only way this_module is None is if inserting caused a change
            # to MODULEPATH making this module unavailable.
            state.unloaded_on_mp_change(other)
            continue

        if other_module.filename != other.filename:
            state.swapped_on_mp_change(other, other_module)
        else:
            other_module.opts = opts[i]

        load_impl(other_module)

    return


def load_partial(module, mode=None):
    """Implementation of load, but only load partially.

    Parameters
    ----------
    module : Module
        The module to load

    Notes
    -----
    This function is used to do a partial load. A partial load is one in which
    only some of the callback functions are actually executed. This function is
    used, e.g., by restore_clone to load a module, but only execute set_alias
    and set_shell_function.  In fact, that is the only current use case.

    """
    # Execute the module
    if mode is not None:
        assert mode in modulecmd.modes.informational
    mode = mode or modulecmd.modes.load_partial
    execmodule(module, mode)
    return


def _partition(key):
    first, _, last = key.partition(":")
    if not last.split():
        first, last = "name", first
    elif first not in ("family", "name"):
        raise Exception("{0} not a known ID to prereq".format(first))
    return first, last


def prereq_any(*prereqs):
    lm_names = [x for m in state.loaded_modules for x in [m.name, m.fullname]]
    lm_fams = [m.family for m in state.loaded_modules if m.family]
    for prereq in prereqs:
        key, val = _partition(prereq)
        a = lm_fams if key == "family" else lm_names
        if val in a:
            return
    raise PrereqMissingError(*prereqs)


def prereq(*prereqs):
    lm_names = [x for m in state.loaded_modules for x in [m.name, m.fullname]]
    lm_fams = [m.family for m in state.loaded_modules if m.family]
    for prereq in prereqs:
        key, val = _partition(prereq)
        a = lm_fams if key == "family" else lm_names
        if val in a:
            continue
        raise PrereqMissingError(val)


def purge(load_after_purge=True):
    """Purge all modules from environment"""
    for module in state.loaded_modules[::-1]:
        if module.is_loaded:
            unload_impl(module)

    if load_after_purge:
        load_after_purge = modulecmd.config.get("load_after_purge")
        tty.debug(str(load_after_purge))
        if load_after_purge is not None:
            for name in load_after_purge:
                load(name)

    return None


def raw(*commands):
    """Run the commands given in `commands`"""
    for command in commands:
        modulecmd.environ.raw_shell_command(command)


def refresh():
    """Unload all modules from environment and reload them"""
    for module in state.loaded_modules[::-1]:
        tty.verbose("Unloading {0}".format(module))
        if module.is_loaded:
            unload_impl(module)
    for module in state.loaded_modules:
        tty.verbose("Loading {0}".format(module))
        if not module.is_loaded:
            load_impl(module)


def reload(name):
    """Reload the module given by `modulename`"""
    module = modulecmd.modulepath.get(name)
    if module is None:
        raise ModuleNotFoundError(name, modulecmd.modulepath)
    if not module.is_loaded:
        tty.warn("{0} is not loaded!".format(module.fullname))
        return
    assert module.is_loaded
    swap_impl(module, module, maintain_state=True, caller="reload")
    return module


def reset():
    initial_env = modulecmd.environ.get(modulecmd.names.initial_env, serialized=True)
    restore_clone_impl(initial_env)
    return initial_env


def show(name, opts=None, insert_at=None, mode="load"):
    """Show the commands that would result from loading module given by `name`

    Parameters
    ----------
    name : string_like
        Module name, full name, or file path
    insert_at : int
        Load the module as the `insert_at`th module.

    Raises
    ------
    ModuleNotFoundError

    """
    # Execute the module
    module = modulecmd.modulepath.get(name)
    if module is None:
        raise ModuleNotFoundError(name, mp=modulecmd.modulepath)

    # Set the command line options
    if opts:
        module.opts = opts

    # Now execute it
    execmodule(module, modulecmd.modes.show)

    # and show it
    sys.stderr.write(state.cur_module_command_his.getvalue())


def source(filename, *args):
    """Source the file `filename`"""
    sourced = modulecmd.environ.get_path(modulecmd.names.sourced_files)
    if filename not in sourced:
        # Only source if it hasn't been sourced
        if not os.path.isfile(filename):
            raise ValueError("{0}: no such file to source".format(filename))
        sourced.append(filename)
        modulecmd.environ.set_path(modulecmd.names.sourced_files, sourced)
        modulecmd.environ.source_file(filename, *args)


def swap(module_a_name, module_b_name, caller="command_line"):
    """Swap modules a and b"""
    module_a = modulecmd.modulepath.get(module_a_name)
    module_b = modulecmd.modulepath.get(module_b_name)
    if module_a is None:
        raise ModuleNotFoundError(module_a_name, modulecmd.modulepath)
    if module_b is None:
        raise ModuleNotFoundError(module_b_name, modulecmd.modulepath)
    if module_b.is_loaded:
        tty.warn("{0} is already loaded!".format(module_b.fullname))
        return module_b
    if not module_a.is_loaded:
        return load_impl(module_b)

    assert module_a.is_loaded

    swap_impl(module_a, module_b, caller=caller)
    state.swapped_explicitly(module_a, module_b)

    return module_b


def swap_impl(module_a, module_b, maintain_state=False, caller="command_line"):
    """The general strategy of swapping is to unload all modules in reverse
    order back to the module to be swapped.  That module is then unloaded
    and its replacement loaded.  Afterward, modules that were previously
    unloaded are reloaded.

    On input:
        module_a is loaded
        module_b is not loaded

    On output:
        module_a is not loaded
        module_b is loaded

    The condition that module_b is not loaded on input is not strictly true
    In the case that a module is reloaded, module_a and module_b would be
    the same, so module_b would also be loaded.

    """

    assert module_a.is_loaded

    # Before swapping, unload modules and later reload
    opts = dict([(m.name, m.opts) for m in state.loaded_modules])
    for (i, other) in enumerate(state.loaded_modules):
        if other.name == module_a.name:
            # All modules coming after this one will be unloaded and
            # reloaded
            to_unload_and_reload = state.loaded_modules[i:]
            break
    else:  # pragma: no cover
        raise NoModulesToSwapError

    # Unload any that need to be unloaded first
    for other in to_unload_and_reload[::-1]:
        unload_impl(other, caller=caller)
    assert other.name == module_a.name

    # Now load it
    load_impl(module_b)

    # Reload any that need to be unloaded first
    for other in to_unload_and_reload[1:]:
        if maintain_state:
            this_module = modulecmd.modulepath.get(other.filename)
        else:
            this_module = modulecmd.modulepath.get(other.acquired_as)
        if this_module is None:
            # The only way this_module is None is if a swap of modules
            # caused a change to MODULEPATH making this module
            # unavailable.
            state.unloaded_on_mp_change(other)
            continue

        if this_module.filename != other.filename:
            state.swapped_on_mp_change(other, this_module)

        # Now load the thing
        this_module.opts = opts.get(this_module.name, this_module.opts)
        load_impl(this_module)

    return module_b


def unload(name, tolerant=False, caller="command_line"):
    """Unload the module given by `name`"""
    module = modulecmd.modulepath.get(name)
    if module is None:
        raise ModuleNotFoundError(name)

    for loaded in state.loaded_modules:
        if loaded.name == name:
            break
        elif loaded.fullname == name:
            break
    else:
        tty.warn("Module {0} is not loaded".format(name))
        return

    if modulecmd.environ.get(modulecmd.names.loaded_collection):  # pragma: no cover
        collection = modulecmd.environ.get(modulecmd.names.loaded_collection)
        tty.debug(
            "Unloading {0} on top of loaded collection {1}. "
            "Removing the collection name from the environment".format(
                module.fullname, collection
            )
        )
        modulecmd.environ.unset(modulecmd.names.loaded_collection)

    unload_impl(loaded, caller)
    return loaded


def unload_impl(module, caller="command_line"):
    """Implementation of unload

    Parameters
    ----------
    module : Module
        The module to unload
    """
    if not module.is_loaded:
        if caller == "command_line":
            raise ModuleNotLoadedError(module)
        return

    if module.refcount == 1 or caller == "command_line":
        execmodule(module, modulecmd.modes.unload)
        state.unregister_module(module)
    else:
        module.refcount -= 1

    module.reset_state()


def unuse(dirname):
    """Remove dirname from MODULEPATH"""

    dirname = os.path.expanduser(dirname)
    if not modulecmd.modulepath.contains(dirname):
        # Nothing to do!
        return

    # load them to initialize list of loaded modules
    _ = state.loaded_modules

    # Now remove dirname from MODULEPATH
    popped_modules = modulecmd.modulepath.remove_path(dirname)
    orphaned = determine_swaps_due_to_removal(popped_modules)

    # Unload orphans
    for orphan in orphaned[::-1]:
        unload_impl(orphan[0])

    # Load modules bumped by removal of dirname from MODULEPATH
    for orphan in orphaned:
        if orphan[1] is None:
            # No longer available!
            state.unloaded_on_mp_change(orphan[0])
        else:
            load_impl(orphan[1])
            state.swapped_on_mp_change(orphan[0], orphan[1])


def determine_swaps_due_to_removal(popped_modules):
    """Determine with of the popped modules should be swapped for modules that
    became available after removing a directory from the modulepath

    Parameters
    ----------
    popped_modules : list of Module
        Modules no longer available due to their modulepath being removed

    Return
    ------
    orphans : list of tuple
        orphans[i][0] loaded module left orphaned
        orphans[i][1] module to be loaded in its place, or None

    """

    # Determine which modules may have moved up in priority due to removal
    # of directory from path. If they have the same name as an orphan, it
    # will be loaded in the orphans place
    orphaned = [m for m in popped_modules if m.is_loaded]
    for (i, orphan) in enumerate(orphaned):
        for attr in ("fullname", "name"):
            other = modulecmd.modulepath.get(getattr(orphan, attr))
            if other is not None:
                orphaned[i] = (orphan, other)
                break
        else:
            orphaned[i] = (orphan, None)
    return orphaned


def use(dirname, append=False, delete=False):
    """Add dirname to MODULEPATH"""
    dirname = os.path.abspath(os.path.expanduser(dirname))
    if delete:
        unuse(dirname)
        return
    elif append:
        return modulecmd.modulepath.append_path(dirname)
    else:
        prepended_modules = modulecmd.modulepath.prepend_path(dirname)
        if prepended_modules is None:
            tty.warn(
                "No modules were found in {0}.  "
                "This path will not be added to MODULEPATH".format(dirname)
            )
            return None
        bumped = determine_swaps_due_to_prepend(prepended_modules)
        for (old, new) in bumped:
            assert old.is_loaded
            if new.fullname == old.acquired_as:
                new.acquired_as = old.acquired_as
            else:
                new.acquired_as = new.fullname
            swap_impl(old, new)
            state.swapped_on_mp_change(old, new)
        return bumped


def determine_swaps_due_to_prepend(prepended_modules):
    """Determine with modules lost precedence and need to be replaced

    Parameters
    ----------
    prepended_modules : list of Module
        These are modules that are now available from prepending their
        modulepath to modulecmd.modulepath

    Returns
    -------
    bumped : list of Module
        List of loaded modules that have lower precedence than a module of the
        same name in prepended_modules. These should be swapped

    """
    # Determine which modules changed in priority due to insertion of new
    # directory in to path
    bumped = []
    loaded_modules = state.loaded_modules

    # Check for fullname first
    fullnames = [m.fullname for m in prepended_modules]
    for (i, module) in enumerate(loaded_modules):
        if module.fullname not in fullnames:
            continue
        prepended_module = prepended_modules[fullnames.index(module.fullname)]
        if prepended_module.filename != module.filename:
            # The new module has the same name, but different filename. Since
            # new module has higher precedence (since its path was prepended to
            # modulepath), we swap them
            bumped.append((module, prepended_module))
            loaded_modules[i] = None

    names = [m.name for m in prepended_modules]
    for (i, module) in enumerate(loaded_modules):
        if module is None or module.name not in names:
            continue
        if module.acquired_as == module.fullname:  # pragma: no cover
            continue
        prepended_module = prepended_modules[names.index(module.name)]
        if prepended_module.filename != module.filename:
            bumped.append((module, prepended_modules[i]))

    return bumped


def trace(string):
    state.cur_module_command_his.write(string)


def whatis(name):
    """Display 'whatis' message for the module given by `name`"""
    module = modulecmd.modulepath.get(name)
    if module is None:
        raise ModuleNotFoundError(name, mp=modulecmd.modulepath)
    load_partial(module, mode=modulecmd.modes.whatis)
    return module.format_whatis()


class ModuleRegisteredError(Exception):
    def __init__(self, module):
        msg = "Attempting to register {0} which is already registered!"
        superini = super(ModuleRegisteredError, self).__init__
        superini(msg.format(module))


class ModuleNotRegisteredError(Exception):
    def __init__(self, module):
        msg = "Attempting to unregister {0} which is not registered!"
        superini = super(ModuleNotRegisteredError, self).__init__
        superini(msg.format(module))


class NoModulesToSwapError(Exception):
    pass
import modulecmd.system
import modulecmd.names
import modulecmd.environ

from modulecmd.tutorial.common import rmdir


def teardown():
    env = modulecmd.environ.get(modulecmd.names.tutorial_save_env, serialized=True)
    if env:
        root = modulecmd.environ.get(modulecmd.names.tutorial_root_path)
        modulecmd.system.purge(load_after_purge=False)
        modulecmd.system.clone.restore_impl(env)
        if root:
            rmdir(root)
import os

import modulecmd.system
import modulecmd.names
import modulecmd.environ
import modulecmd.modulepath
from modulecmd.tutorial.common import destination_root, mkdirp, rmdir
from modulecmd.tutorial.common import join_path, make_executable, sanitize


def basic_usage():

    env = modulecmd.environ.copy(include_os=True)
    modulecmd.system.purge(load_after_purge=False)
    modulecmd.modulepath.clear()
    root = destination_root()

    rmdir(root)
    mkdirp(root)

    basic_dirs = gen_basic_modules(root)

    for basic_dir in basic_dirs[:2]:
        modulecmd.modulepath.append_path(basic_dir)

    if not modulecmd.environ.get(modulecmd.names.tutorial_save_env, serialized=True):
        modulecmd.environ.set(modulecmd.names.tutorial_save_env, env, serialize=True)

    modulecmd.environ.set(modulecmd.names.tutorial_root_path, root)

    return


def write_basic_module_and_script(name, version, modulepath, scriptpath):

    fullname = name
    if version is not None:
        fullname = join_path(name, version)

    if version is None:
        scriptname = "script-{0}".format(name).lower()
    else:
        scriptname = "script-{0}-{1}".format(name, version).lower()

    modulefile = join_path(modulepath, fullname + ".py")
    scriptfile = join_path(scriptpath, scriptname)

    mkdirp(os.path.dirname(modulefile))
    mkdirp(os.path.dirname(scriptfile))

    with open(modulefile, "w") as fh:
        fh.write("\n# Prepend the PATH environment variable with my bin directory\n")
        fh.write("prepend_path('PATH', {0!r})\n".format(sanitize(scriptpath)))

    with open(scriptfile, "w") as fh:
        fh.write("#!/usr/bin/env sh\n")
        fh.write(
            'echo "This is a script associated with module {0} in {1}"\n'.format(
                fullname, modulepath
            )
        )

    make_executable(scriptfile)


def gen_basic_modules(base_dir):
    """
    modules/basic/1
      A.py
      B.py
      C/1.0.py
    modules/basic/2
      A.py
      B.py
      C/2.0.py

    """

    basic_sw_dir = mkdirp(base_dir, "basic", "sw")
    basic_modules_dir = mkdirp(base_dir, "basic", "modules")

    dirs = []
    for i in range(3):
        modulepath = mkdirp(basic_modules_dir, str(i + 1))
        sw_dir = mkdirp(basic_sw_dir, str(i + 1))

        if i == 0:
            # A exists only in one directory
            name = "A"
            scriptpath = mkdirp(sw_dir, name, "bin")
            write_basic_module_and_script(name, None, modulepath, scriptpath)

        name = "B"
        scriptpath = mkdirp(sw_dir, name, "bin")
        write_basic_module_and_script(name, None, modulepath, scriptpath)

        name = "C"
        version = "{0}.0".format(i + 1)
        scriptpath = mkdirp(sw_dir, name, version, "bin")
        write_basic_module_and_script(name, version, modulepath, scriptpath)

        dirs.append(modulepath)

    return dirs
from modulecmd.tutorial.basic_usage import basic_usage
from modulecmd.tutorial.teardown import teardown
from modulecmd.tutorial.hierarchy import hierarchy
import modulecmd.system
import modulecmd.names
import modulecmd.environ
import modulecmd.modulepath
from modulecmd.tutorial.common import destination_root, mkdirp, rmdir, join_path


def hierarchy():

    env = modulecmd.environ.copy(include_os=True)
    modulecmd.system.purge(load_after_purge=False)
    modulecmd.modulepath.clear()

    root = destination_root()

    rmdir(root)
    mkdirp(root)

    core_base_dir = mkdirp(root, "core")
    compiler_base_dir = mkdirp(root, "compiler")
    mpi_base_dir = mkdirp(root, "mpi")

    compilers = [("occ", ("6.0", "7.0")), ("pcc", ("2016.01", "2017.02"))]
    mpis = [("ompi", ("1.0", "2.0"))]

    gen_core_modules(core_base_dir, compiler_base_dir, compilers)
    gen_compiler_dep_modules(compiler_base_dir, mpi_base_dir, compilers, mpis)
    gen_mpi_dep_modules(mpi_base_dir, compilers, mpis)

    modulecmd.modulepath.append_path(core_base_dir)

    if not modulecmd.environ.get(modulecmd.names.tutorial_save_env, serialized=True):
        modulecmd.environ.set(modulecmd.names.tutorial_save_env, env, serialize=True)

    return


def gen_mpi_dep_modules(mpi_base_dir, compilers, mpis):

    # Build the mpi dependent modules
    for (mpi_vendor, mpi_versions) in mpis:
        for mpi_version in mpi_versions:
            for (compiler_vendor, compiler_versions) in compilers:
                for compiler_version in compiler_versions:
                    dest_dir = mkdirp(
                        mpi_base_dir,
                        compiler_vendor,
                        compiler_version,
                        mpi_vendor,
                        mpi_version,
                    )

                    # Write
                    for name in "XYZ":
                        module_dir = mkdirp(dest_dir, name)
                        for version in ("2.0", "3.0"):
                            with open(
                                join_path(module_dir, version + ".py"), "w"
                            ) as fh:
                                fh.write(
                                    "setenv({0!r}, '{0}/{1}-{2}/{3}-{4}/{5}')\n".format(
                                        name,
                                        version,
                                        compiler_vendor,
                                        compiler_version,
                                        mpi_vendor,
                                        mpi_version,
                                    )
                                )


def gen_compiler_dep_modules(compiler_base_dir, mpi_base_dir, compilers, mpis):

    # Build the compiler modules that unlock compiler dependent modules
    for (compiler_vendor, compiler_versions) in compilers:
        for compiler_version in compiler_versions:
            dest_dir = mkdirp(compiler_base_dir, compiler_vendor, compiler_version)
            for name in "QRS":
                module_dir = mkdirp(dest_dir, name)
                for version in ("1.0", "2.0"):
                    with open(join_path(module_dir, version + ".py"), "w") as fh:
                        fh.write(
                            "setenv({0!r}, '{0}/{1}-{2}/{3}')\n".format(
                                name, version, compiler_vendor, compiler_version
                            )
                        )

            # MPI unlock modules
            for (mpi_vendor, mpi_versions) in mpis:
                module_dir = mkdirp(dest_dir, mpi_vendor)
                for mpi_version in mpi_versions:
                    unlocks = join_path(
                        mpi_base_dir,
                        compiler_vendor,
                        compiler_version,
                        mpi_vendor,
                        mpi_version,
                    )
                    with open(join_path(module_dir, mpi_version + ".py"), "w") as fh:
                        fh.write("family('mpi')\n")
                        fh.write("use({0!r})\n".format(unlocks))


def gen_core_modules(core_base_dir, compiler_base_dir, compilers):

    # Build the core modules
    for name in "AB":
        with open(join_path(core_base_dir, name + ".py"), "w") as fh:
            fh.write("setenv({0!r}, {0!r})\n".format(name))

    for name in "CD":
        module_dir = mkdirp(core_base_dir, name)
        for version in ("1.0", "2.0"):
            with open(join_path(module_dir, version + ".py"), "w") as fh:
                fh.write("setenv({0!r}, '{0}/{1}')\n".format(name, version))

    for (vendor, versions) in compilers:
        module_dir = mkdirp(core_base_dir, vendor)
        for version in versions:
            unlocks = join_path(compiler_base_dir, vendor, version)
            with open(join_path(module_dir, version + ".py"), "w") as fh:
                fh.write("family('compiler')\n")
                fh.write("use({0!r})\n".format(unlocks))
import os
import json
from ordereddict_backport import OrderedDict

import modulecmd.modulepath
import modulecmd.names
import modulecmd.paths
import modulecmd.environ

import llnl.util.tty as tty


def upgrade(new, old, old_version):  # pragma: no cover
    if old_version is None:
        return upgrade_None_to_1_0(new, old)
    elif old_version != new.version:
        raise ValueError(
            "No known conversion from Collections version "
            "{0} to {1}".format(old_version, new.version)
        )


def upgrade_None_to_1_0(new, old, depth=[0]):

    depth[0] += 1
    if depth[0] > 1:
        raise ValueError("Recursion!")

    version_string = ".".join(str(_) for _ in new.version)
    tty.info(
        "Converting Modulecmd.py collections version 0.0 to "
        "version {0}".format(version_string)
    )
    new_collections = {}
    for (name, old_collection) in old.items():
        new_collection = OrderedDict()
        mp = modulecmd.modulepath.Modulepath([])
        for (path, m_descs) in old_collection:
            if new_collection is None:
                break
            if not os.path.isdir(path):
                tty.warn(
                    "Collection {0} contains directory {1} which "
                    "does not exist!  This collection will be skipped".format(
                        name, path
                    )
                )
                new_collection = None
                break
            avail = mp.append_path(path)
            if avail is None:
                tty.warn(
                    "Collection {0} contains directory {1} which "
                    "does not have any available modules!  "
                    "This collection will be skipped".format(name, path)
                )
                new_collection = None
                break
            for (fullname, filename, opts) in m_descs:
                m = mp.get(filename)
                if m is None:
                    tty.warn(
                        "Collection {0} requests module {1} which "
                        "can not be found! This collection will be skipped".format(
                            name, fullname
                        )
                    )
                    new_collection = None
                    break
                m.opts = opts
                m.acquired_as = m.fullname
                ar = m.asdict()
                new_collection.setdefault(m.modulepath, []).append(ar)

        if new_collection is None:
            tty.warn(
                "Skipping collection {0} because of previous " "errors".format(name)
            )
            continue

        new_collections[name] = list(new_collection.items())

    bak = new.filename + ".bak"
    with open(bak, "w") as fh:
        json.dump(old, fh, indent=2)

    new.write(list(new_collections.items()), new.filename)
    return new_collections
import os
import ruamel.yaml as yaml
from six import StringIO

import modulecmd.names
import modulecmd.paths

from llnl.util.lang import Singleton
from llnl.util.tty import terminal_size
from llnl.util.tty.color import colorize
from llnl.util.tty.colify import colified


class Aliases(object):
    """Provides mechanism for having aliases to other modules"""

    def __init__(self, filename):
        self.filename = filename
        self._data = None

    @property
    def data(self):
        if self._data is None:
            self._data = self.read(self.filename)
        return self._data

    def get(self, name):
        if os.path.isdir(name):
            return self.getby_modulepath(name)
        else:
            return self.getby_name(name)

    def getby_name(self, name):
        return self.data.get(name)

    def getby_modulepath(self, dirname):
        value = []
        for (name, info) in self.data.items():
            if info["modulepath"] == dirname:
                value.append((name, info["target"]))
        return value or None

    def read(self, filename):
        if os.path.isfile(filename):  # pragma: no cover
            data = yaml.load(open(filename))
            aliases = data.pop("aliases", dict())
            if data:
                raise ValueError(
                    "Expected single top level key " "'aliases' in {0}".format(filename)
                )
            return aliases
        return dict()

    def write(self, aliases, filename):
        with open(filename, "w") as fh:
            yaml.dump({"aliases": aliases}, fh, default_flow_style=False)

    def save(self, target, name):
        """Save the alias 'name' to target"""
        self.data[name] = {
            "target": target.fullname,
            "filename": target.filename,
            "modulepath": target.modulepath,
        }
        self.write(self.data, self.filename)
        return

    def remove(self, name):
        self.data.pop(name, None)
        self.write(self.data, self.filename)

    def avail(self, terse=False):
        if not self.data:  # pragma: no cover
            return ""

        keys = sorted(list(self.data.keys()))
        fun = lambda key: "{0} -> {1} ({2})".format(
            key,
            self.data[key]["target"],
            colorize("@C{%s}" % self.data[key]["modulepath"]),
        )
        names = [fun(_) for _ in keys]

        sio = StringIO()
        if not terse:
            _, width = terminal_size()
            s = colified(names, width=width)
            sio.write("{0}\n{1}\n".format(" Aliases ".center(width, "-"), s))
        else:
            sio.write("{0}\n".format("\n".join(c for c in names)))
        string = sio.getvalue()
        return string


def factory():
    basename = modulecmd.names.aliases_file_basename
    filename = modulecmd.paths.join_user(basename, cache=True)
    return Aliases(filename)


aliases = Singleton(factory)


def save(target, alias_name):
    return aliases.save(target, alias_name)


def remove(name):
    aliases.remove(name)


def get(name):
    return aliases.get(name)


def avail(terse=False):
    return aliases.avail(terse=terse)
import os
import ruamel.yaml as yaml
import modulecmd.paths
import modulecmd.names
from modulecmd.util.lang import split
from llnl.util.lang import Singleton
from spack.util.executable import which


def load_config(filename):
    dict = yaml.load(open(filename))
    return dict.get("config")


has_tclsh = which("tclsh") is not None


class Configuration(object):
    scope_names = ["defaults", "user", "environment", "command_line"]

    def __init__(self):
        self.scopes = {}

    def push_scope(self, scope_name, data):
        """Add a scope to the Configuration."""
        if "defaults" in self.scopes and scope_name != "defaults":
            self.verify_config(data, scope_name)
        self.scopes.setdefault(scope_name, {}).update(dict(data))

    def verify_config(self, data, scope):
        """Verify that the types match those of the default scope"""
        for (key, val) in data.items():
            try:
                default = self.scopes["defaults"][key]
            except KeyError:
                msg = "Unknown user config var {0!r}".format(key)
                raise ValueError(msg)
            if scope == "environment":
                # Environment variables are always strings.
                if isinstance(default, list):
                    val = split(val, sep=",")
                else:
                    val = type(default)(val)
                data[key] = val
            elif type(default) != type(val):
                m = "User config var {0!r} must be of type {1!r}, not {2!r}"
                msg = m.format(key, type(default).__name__, type(val).__name__)
                raise ValueError(msg)

    def remove_scope(self, scope_name):
        return self.scopes.pop(scope_name, None)

    def get(self, key, default=None, scope=None):
        if key is None:
            if scope is not None:
                return self.scopes[scope]
            cfg = {}
            for scope_name in self.scope_names[::-1]:
                if scope_name in self.scopes:
                    cfg.update(self.scopes[scope_name])
            return cfg

        if scope is not None:
            value = self.scopes[scope].get(key, default)
        else:
            for scope_name in self.scope_names[::-1]:
                if scope_name in self.scopes:
                    value = self.scopes[scope_name].get(key)
                    if value is not None:
                        break
            else:
                value = default
        return value

    def set(self, key, value, scope=None):
        if scope is not None:
            self.scopes.setdefault(scope, {}).update({key: value})
        else:
            for scope_name in self.scope_names[::-1]:
                self.scopes.setdefault(scope_name, {}).update({key: value})


def factory():
    """Singleton Configuration instance.

    This constructs one instance associated with this module and returns
    it. It is bundled inside a function so that configuratoin can be
    initialized lazily.

    Returns
    -------
    cfg : Configuration
        object for accessing Modulecmd.py configuration

    """
    cfg = Configuration()

    config_basename = modulecmd.names.config_file_basename

    default_config_file = os.path.join(
        modulecmd.paths.etc_path, "defaults", config_basename
    )
    defaults = load_config(default_config_file)
    cfg.push_scope("defaults", defaults)

    admin_config_file = os.path.join(modulecmd.paths.etc_path, config_basename)
    if os.path.isfile(admin_config_file):
        admin = load_config(admin_config_file)
        cfg.push_scope("user", admin)

    user_config_file = os.path.join(modulecmd.paths.user_config_path, config_basename)
    if os.path.exists(user_config_file):
        user = load_config(user_config_file)
        cfg.push_scope("user", user)

    # Environment variable
    env = {}
    for key in defaults:
        envar = "PYMOD_{0}".format(key.upper())
        if os.getenv(envar):
            key = envar[6:].lower()
            value = os.environ[envar]
            if isinstance(defaults[key], bool):  # pragma: no cover
                value = False if value.upper() in ("0", "FALSE", "NO") else True
            env[key] = value

    if env:
        cfg.push_scope("environment", env)

    return cfg


config = Singleton(factory)


def get(key, default=None, scope=None):
    """Module-level wrapper for ``Configuration.get()``."""
    return config.get(key, default, scope)


def set(key, value, scope=None):  # pragma: no cover
    """Convenience function for getting single values in config files."""
    return config.set(key, value, scope)


class ConfigError(Exception):
    pass


class ConfigSectionError(Exception):
    pass
"""Defines paths that are part of modulecmd's directory structure.

Do not import other ``modulecmd`` modules here. This module is used
throughout Modulecmd.py and should bring in a minimal number of external
dependencies.
"""
import os
import sys


def ancestor(dir, n=1):
    """Get the nth ancestor of a directory."""
    parent = os.path.abspath(dir)
    for i in range(n):
        parent = os.path.dirname(parent)
    return parent


#: This file lives in $prefix/lib/modulecmd/modulecmd/__file__
prefix = ancestor(__file__, 4)

#: synonym for prefix
modulecmd_root = prefix

#: bin directory in the modulecmd prefix
bin_path = os.path.join(prefix, "bin")

#: The modulecmd script itself
modulecmd_script = os.path.join(bin_path, "modulecmd")

# modulecmd directory hierarchy
lib_path = os.path.join(prefix, "lib", "modulecmd")
external_path = os.path.join(lib_path, "contrib")
module_path = os.path.join(lib_path, "modulecmd")
command_path = os.path.join(module_path, "command")
callback_path = os.path.join(module_path, "callback")
test_path = os.path.join(module_path, "test")
modulepath_path = os.path.join(module_path, "modulepath")
var_path = os.path.join(prefix, "var", "modulecmd")
share_path = os.path.join(prefix, "share", "modulecmd")
docs_path = os.path.join(prefix, "docs", "modulecmd")
etc_path = os.path.join(prefix, "etc", "modulecmd")


#: User configuration location
user_config_path = os.getenv("PYMOD_USER_CONFIG_PATH", os.path.expanduser("~/.modulecmd"))
user_cache_path = os.getenv("PYMOD_USER_CACHE_PATH", os.path.expanduser("~/.modulecmd/cache"))

if not os.path.isdir(user_config_path):  # pragma: no cover
    os.makedirs(user_config_path)

if not os.path.isdir(user_cache_path):  # pragma: no cover
    os.makedirs(user_cache_path)

def join_user(basename, cache=False):
    if cache:
        return os.path.join(user_cache_path, basename)
    return os.path.join(user_config_path, basename)


del sys
import os
import sys
from contextlib import contextmanager

from modulecmd.util.tty.pager import pager
from modulecmd.util.tty.grep import grep_pat_in_string


@contextmanager
def redirect_stdout(stdout=sys.stderr):
    old_stdout = sys.stdout
    sys.stdout = stdout
    yield
    sys.stdout = old_stdout


def fileno(file_or_fd):
    fd = getattr(file_or_fd, "fileno", lambda: file_or_fd)()
    if not isinstance(fd, int):
        raise ValueError("Expected a file (`.fileno()`) or a file descriptor")
    return fd


@contextmanager
def redirect_stdout2(to=sys.stderr, stdout=None):
    """From:  http://stackoverflow.com/questions/4675728/
                        redirect-stdout-to-a-file-in-python/22434262#22434262

    """
    if stdout is None:
        stdout = sys.stdout

    stdout_fd = fileno(stdout)
    # copy stdout_fd before it is overwritten
    # NOTE: `copied` is inheritable on Windows when duplicating a standard stream
    with os.fdopen(os.dup(stdout_fd), "wb") as copied:
        stdout.flush()  # flush library buffers that dup2 knows nothing about
        try:
            os.dup2(fileno(to), stdout_fd)  # $ exec >&to
        except ValueError:  # filename
            with open(to, "wb") as to_file:
                os.dup2(to_file.fileno(), stdout_fd)  # $ exec > to
        try:
            yield stdout  # allow code to be run with the redirected stdout
        finally:
            # restore stdout to its previous value
            # NOTE: dup2 makes stdout_fd inheritable unconditionally
            stdout.flush()
            os.dup2(copied.fileno(), stdout_fd)  # $ exec >&copied
import re
from .shell import Shell


class Bash(Shell):
    name = "bash"

    def format_environment_variable(self, key, val=None):
        """Define variable in bash syntax"""
        if val is None:
            return "unset {0};".format(key)
        return '{0}="{1}";\nexport {0};'.format(key, val)

    def format_shell_function(self, key, val=None):
        # Define or undefine a bash shell function.
        # Modify module definition of function so that there is
        # one and only one semicolon at the end.
        if val is None:
            return "unset -f {0} 2> /dev/null || true;".format(key)
        val = val.rstrip(";")
        return "{0}() {{ {1}; }};".format(key, val)

    def format_alias(self, key, val=None):
        # Define or undefine a bash shell alias.
        # Modify module definition of function so that there is
        # one and only one semicolon at the end.
        if val is None:
            return "unalias {0} 2> /dev/null || true;".format(key)
        val = val.rstrip(";")
        return "alias {0}='{1}';".format(key, val)

    def format_source_command(self, filename, *args):
        return "source {0} {1}".format(filename, " ".join(args)).strip()

    def filter_key(self, key):
        return key.startswith(("BASH_FUNC",))

    def cloned_env(self, environ):  # pragma: no cover
        env = dict()
        for (key, val) in environ.items():
            match = re.search("BASH_FUNC_(?P<n>.*?)%%", key)
            if match:
                key = match.group("n")
                val = val[val.find("{") + 1 : val.rfind("}")].strip()
            env[key] = val
        return env

    def switch(self):  # pragma: no cover
        """Switch the underlying module implementation"""
        import os
        from six import StringIO
        from modulecmd.util.lang import which

        for (key, val) in os.environ.items():
            if key.startswith("BASH_FUNC_module"):
                break
        else:
            raise Exception("Unable to find module bash function")
        current_module_implementation = "modulecmd" if "PYMOD_CMD" in val else "tcl"

        s = StringIO()
        if current_module_implementation == "modulecmd":
            if os.getenv("LMOD_CMD"):
                modulecmd = os.environ["LMOD_CMD"]
            else:
                modulecmd = which("modulecmd")
                if modulecmd is None:
                    raise Exception("Unable to find modulecmd executable")
            s.write('module() { eval $(%s bash "$@"); };' % modulecmd)
            s.write("unset -f module;")
            s.write('modulecmd() { eval $(python -E $PYMOD_CMD bash "$@"); };')
            s.write("export -f modulecmd;")
            s.write('module() { eval $(%s bash "$@"); };' % modulecmd)
            s.write("export -f module;")
        else:
            s.write("unset -f module;")
            s.write("unset -f modulecmd;")
            s.write('module() { eval $(python -E $PYMOD_CMD bash "$@"); };')
            s.write("export -f module;")
        return s.getvalue()
import os
from .bash import Bash
from .csh import Csh
from .python import Python
from .shell import Shell

import modulecmd.config
from llnl.util.lang import Singleton


__shells__ = (Shell, Bash, Csh, Python)

default_shell = os.path.basename(os.getenv("SHELL", "bash"))


def get_shell(shell_name=None):
    """Shell factory method

    Parameters
    ----------
    shell_name : str
        The name of the shell

    Returns
    -------
    shell : Shell
        The instantiated shell whose type's name matches shell_name

    """
    global name
    if shell_name is None:
        shell_name = modulecmd.config.get("default_shell")
    for shelltype in __shells__:
        if shell_name == shelltype.name:
            name = shell_name
            return shelltype()
    raise ValueError("Unknown shell " + shell_name)


_shell = Singleton(get_shell)
name = None


def set_shell(shell_name):
    """Set the shell singleton to a specific value. """
    global _shell, name
    if shell_name != _shell.name:
        _shell = get_shell(shell_name)


def format_source_command(filename, *args):
    return _shell.format_source_command(filename, *args)


def format_output(
    environ,
    aliases=None,
    shell_functions=None,
    files_to_source=None,
    raw_shell_commands=None
):
    return _shell.format_output(
        environ,
        aliases=aliases,
        shell_functions=shell_functions,
        files_to_source=files_to_source,
        raw_shell_commands=raw_shell_commands
    )


def filter_env(environ):
    return _shell.filter_env(environ)


def filter_key(key):
    return _shell.filter_key(key)


def switch():  # pragma: no cover
    return _shell.switch()
from modulecmd.util.lang import split


class Version:
    """Class to represent a module's version

    Assumes module version is of form

    [major[.minor[.patch[-variant]]]]

    """

    def __init__(self, version_string=None):
        self.tuple = tuple()
        self.string = version_string or ""
        if version_string is not None:
            try:
                version_string, variant = version_string.split("-")
            except ValueError:
                variant = None
            parts = [try_int(part) for part in split(version_string, ".")]
            if variant is not None:
                parts.append(try_int(variant))
            self.tuple = tuple(parts)
        for (i, attr) in enumerate(("major", "minor", "patch", "variant")):
            try:
                value = self.tuple[i]
            except IndexError:
                value = None
            setattr(self, attr, value)

    def __repr__(self):
        return self.string

    def __str__(self):  # pragma: no cover
        return self.string

    def __gt__(self, other):
        try:
            return self.tuple > other.tuple
        except TypeError:
            return self.string > other.string

    def __lt__(self, other):
        return not self > other

    def __eq__(self, other):
        if not isinstance(other, Version):
            other = Version(other)
        return self.tuple == other.tuple

    def __nonzero__(self):
        return self.major is not None

    def __bool__(self):
        return self.major is not None

    @property
    def info(self):
        return self.tuple


def try_int(item):
    try:
        return int(item)
    except:  # noqa: E722
        return item
import os

import modulecmd.config
from modulecmd.module.module import *

import llnl.util.tty as tty


def factory(root, path):
    filename = os.path.join(root, path)
    if not os.path.isfile(filename):  # pragma: no cover
        tty.verbose("{0} does not exist".format(filename))
        return None
    elif filename.endswith(("~",)) or filename.startswith((".#",)):  # pragma: no cover
        # Don't read backup files
        return None

    if filename.endswith(".py"):
        module_type = PyModule
    elif is_tcl_module(filename):
        module_type = TclModule
    else:
        return None

    module = module_type(root, path)
    if modulecmd.config.get("debug"):  # pragma: no cover
        if module_type == TclModule and "gcc" in filename:
            tty.debug(module.name)
            tty.debug(module.modulepath)
            tty.debug(module.filename, "\n")

    return module


def as_dict(module):
    return {
        "type": type(module).__name__,
        "file": module.filename,
        "modulepath": module.modulepath,
    }


def from_dict(dikt):
    filename = dikt["file"]
    root = dikt["modulepath"]
    assert filename.startswith(root)
    path = filename.replace(root+os.path.sep, "")
    module_type = {"PyModule": PyModule, "TclModule": TclModule}[dikt["type"]]
    try:
        module = module_type(root, path)
    except IOError:
        return None
    assert module.filename == filename
    return module


def is_tcl_module(filename):
    tcl_header = "#%Module"
    try:
        return open(filename).readline().startswith(tcl_header)
    except (IOError, UnicodeDecodeError):  # pragma: no cover
        return False
import os

import modulecmd.system
import modulecmd.modes
import modulecmd.paths
import modulecmd.names
import modulecmd.environ
from spack.util.executable import Executable


def tcl2py(module, mode):
    tcl2py_exe = os.path.join(modulecmd.paths.bin_path, "tcl2py.tcl")
    tcl2py = Executable(tcl2py_exe)

    env = modulecmd.environ.filtered(include_os=True)

    mode = modulecmd.modes.as_string(mode)
    mode = {"show": "display"}.get(mode, mode)

    args = []
    # loaded modules
    loaded_modules = modulecmd.system.loaded_modules()
    lm_names = list(set([x for m in loaded_modules for x in [m.name, m.fullname]]))
    args.extend(("-l", ":".join(lm_names)))
    args.extend(("-f", module.fullname))
    args.extend(("-m", mode))
    args.extend(("-u", module.name))
    args.extend(("-s", "bash"))

    ldlib = env.get(modulecmd.names.platform_ld_library_path)
    if ldlib:
        args.extend(("-L", ldlib))

    ld_preload = env.get(modulecmd.names.ld_preload)
    if ld_preload:
        args.extend(("-P", ld_preload))

    args.append(module.filename)

    kwargs = {"env": env, "output": str}
    output = tcl2py(*args, **kwargs)
    #  name = module.name
    #  family = None
    #  if name.endswith('python'):
    #      family = 'python'
    #  elif name.startswith(('gcc', 'intel', 'pgi')):
    #      family = 'compiler'
    #  elif name.startswith(('openmpi', 'mpich', )):
    #      family = 'mpi'
    #  else:
    #      family = None
    #
    #  if family is not None:
    #      output = 'family("{0}")\n'.format(family) + output
    return output
import os
from six import StringIO
from textwrap import fill

import modulecmd.system
import modulecmd.config
from modulecmd.module.meta import MetaData
from modulecmd.module.tcl2py import tcl2py
from modulecmd.module.version import Version

from modulecmd.util.lang import textfill
import llnl.util.tty as tty
from llnl.util.tty import terminal_size

__all__ = ["Namespace", "Module", "PyModule", "TclModule"]


class Module(object):
    ext = None

    def __init__(self, root, path):

        self.filename = os.path.join(root, path)

        if not os.path.isfile(self.filename):
            raise IOError("{0} is not a file".format(self.filename))

        parts = path.split(os.path.sep)
        if self.ext:
            parts[-1], ext = os.path.splitext(parts[-1])
            assert ext == self.ext, "ext={0!r}!={1!r}".format(ext, self.ext)

        version = variant = None
        if len(parts) == 1:
            name = parts[0]
        elif len(parts) == 2:
            name, version = parts
        elif len(parts) == 3:
            name, version, variant = parts
        else:
            name = os.path.join(*parts)

        self.name = name
        self.version = Version(version)
        self.variant = Version(variant)

        self.modulepath = root
        self.family = None
        self.whatisstr = ""
        self.helpstr = None
        self.is_default = False
        self._unlocked_by_me = []
        self.marked_as_default = False
        self._acquired_as = None  # How the module was initially loaded
        self._refcount = 0

        # Mapping containing items set on command line (before parsing)
        self.kwargv = {}

        # Options registered by a module using `add_option`
        self.registered_options = []

    def __str__(self):
        return "Module(name={0})".format(self.fullname)

    def __repr__(self):
        return "Module(name={0})".format(self.fullname)

    def asdict(self):
        d = dict(
            fullname=self.fullname,
            filename=self.filename,
            family=self.family,
            opts=self.opts,
            acquired_as=self.acquired_as,
            refcount=self.refcount,
            modulepath=self.modulepath,
        )
        return d

    @property
    def is_loaded(self):
        lm_files = [m.filename for m in modulecmd.system.loaded_modules()]
        return self.filename in lm_files

    @property
    def is_enabled(self):
        return True

    @property
    def is_hidden(self):
        return not self.is_enabled

    @property
    def acquired_as(self):
        return self._acquired_as

    @property
    def opts(self):
        return self.kwargv

    @opts.setter
    def opts(self, opts):
        self.kwargv = {} if not opts else dict(opts)

    @acquired_as.setter
    def acquired_as(self, arg):
        assert (
            arg == self.filename
            or arg == self.name
            or arg == self.fullname
            or self.endswith(arg)
        ), "Bad arg: {0} (fullname: {1})".format(arg, self.fullname)
        self._acquired_as = arg

    @property
    def refcount(self):
        return self._refcount

    @refcount.setter
    def refcount(self, count):
        if count < 0:
            raise ValueError(
                "Negative reference count for {0}.  This should "
                "never happen.  Please report this failure to "
                "the Modulecmd.py developers".format(self)
            )
        self._refcount = count

    @property
    def path(self):
        return self.filename if self.ext is None else os.path.splitext(self.filename)[0]

    def endswith(self, string):
        return len(string) > len(self.fullname) and self.path.endswith(string)

    def unlocks_path(self, path):
        """Called by the callback `use` to register which paths are unlocked
        by me.
        """
        if path not in self._unlocked_by_me:
            self._unlocked_by_me.append(path)

    def unlocks(self, path=None):
        """Return whether `path` is unlocked by this module. If `path is
        None`, then return the list of paths that are unlocked by this
        module.

        The list _unlocked_by_me is populated by the callback `use` through
        the `unlocks_path` function.
        """
        if path is None:
            return list(self._unlocked_by_me)
        return path in self._unlocked_by_me

    def unlocked_by(self):
        """Returns the module[s] that unlock this module, if any"""
        unlocks_me = []
        loaded_modules = modulecmd.system.loaded_modules()
        dirname = self.modulepath
        for module in loaded_modules[::-1]:
            if module.unlocks(path=dirname):
                unlocks_me.append(module)
                dirname = module.modulepath
        return list(unlocks_me[::-1])

    def read(self, mode):
        raise NotImplementedError  # pragma: no cover

    def prepare(self):
        pass

    def reset_state(self):
        self.kwargv = {}

    @property
    def fullname(self):
        if not self.version:
            assert not self.variant
            return self.name
        elif not self.variant:
            return os.path.sep.join((self.name, self.version.string))
        return os.path.sep.join((self.name, self.version.string, self.variant.string))

    def format_dl_status(self):
        if self.is_default and self.is_loaded:
            return self.fullname + " (D,L)"
        elif self.is_default:  # pragma: no cover
            return self.fullname + " (D)"
        elif self.is_loaded:
            return self.fullname + " (L)"
        return self.fullname

    def format_whatis(self):
        if not self.whatisstr:  # pragma: no cover
            return '{0}: no "whatis" description has been provided'.format(
                self.fullname
            )
        sio = StringIO()
        _, width = terminal_size()
        rule = "=" * width
        head = "{0}".format((" " + self.name + " ").center(width, "="))
        text_width = min(width, 80)
        sio.write(head + "\n")
        sio.write(fill(self.whatisstr, width=text_width) + "\n")
        option_help = self.option_help_string()
        if option_help:  # pragma: no cover
            sio.write("\n" + option_help + "\n")
        sio.write(rule)
        return sio.getvalue()

    def set_whatis(self, *args, **kwargs):
        if isinstance(self, TclModule):
            if len(args) != 1:
                raise ValueError("unknown whatis args length for tcl module")
            self.whatisstr += args[0] + "\n"
        else:
            for arg in args:
                self.whatisstr += arg + "\n"
        for (key, value) in kwargs.items():
            key = " ".join(key.split("_"))
            self.whatisstr += "\n" + key + ":\n"
            self.whatisstr += textfill(value, indent=2)

    def format_help(self):
        if self.helpstr is None:
            return "{0}: no help string provided".format(self.fullname)

        sio = StringIO()
        _, width = terminal_size()
        rule = "=" * width
        head = "{0}".format((" " + self.name + " ").center(width, "="))
        sio.write(head + "\n")
        sio.write(fill(self.helpstr) + "\n")
        option_help = self.option_help_string()
        if option_help:  # pragma: no cover
            sio.write("\n" + option_help + "\n")
        sio.write(rule)
        return sio.getvalue()

    def set_help_string(self, helpstr):
        self.helpstr = helpstr

    def add_option(self, *args, **kwargs):
        if not args:
            raise TypeError("add_option() missing 1 required positional argument: 'name'")
        default = kwargs.pop("default", None)
        help = kwargs.pop("help", None)
        name = max(args, key=len)
        dest = kwargs.pop("dest", name)
        type = kwargs.pop("type", str)
        if kwargs:
            kwd = list(kwargs.keys())[0]
            raise TypeError("add_option() got an unexpected keyword argument {0!r}".format(kwd))
        opt = ModuleOption(name, dest=dest, default=default, keys=list(args), help=help, type=type)
        self.registered_options.append(opt)

    def parse_opts(self):
        parsed = Namespace()
        parsed.set_defaults(*self.registered_options)

        # Set passed arguments
        unrecognized = []
        for (key, value) in self.kwargv.items():
            if type is bool:
                value = Boolean(value)
                if value is None:
                    v = self.kwargv[key]
                    tty.die("Expected {0} to be a boolean, got {1}".format(key, v))
            for opt in self.registered_options:
                if key in opt.keys:
                    parsed.set(opt.dest, value)
                    break
            else:
                unrecognized.append(key)
        if unrecognized:
            tty.die(
                "{0}: unrecognized options: {1}".format(
                    self.fullname, ", ".join(unrecognized)
                )
            )

        return parsed

    def option_help_string(self):
        if not self.registered_options:
            return None
        max_opt_name_length = max([len(opt.dest) for opt in self.registered_options])
        column_start = min(20, max_opt_name_length)
        help_string = StringIO()
        help_string.write("Module options:\n")
        text_width = 80 - column_start
        subsequent_indent = " " * column_start
        for opt in self.registered_options:
            pad = " " * max(column_start - len(opt.dest) - 2, 2)
            line = "  {0}{1}".format(opt.dest, pad)
            this_help_str = opt.help
            if this_help_str is not None:
                this_help_str = fill(
                    this_help_str, width=text_width, subsequent_indent=subsequent_indent
                )
                line += this_help_str
            help_string.write(line + "\n")
        return help_string.getvalue().rstrip()


class PyModule(Module):
    ext = ".py"

    def __init__(self, modulepath, *parts):
        # strip the file extension off the last part and call class initializer
        super(PyModule, self).__init__(modulepath, *parts)
        self.metadata = MetaData()
        self.metadata.parse(self.filename)

    @property
    def is_enabled(self):
        return self.metadata.is_enabled

    def read(self, mode):
        return open(self.filename, "r").read()


class TclModule(Module):

    def read(self, mode):
        if not modulecmd.config.has_tclsh:  # pragma: no cover
            raise TCLSHNotFoundError
        try:
            return tcl2py(self, mode)
        except Exception as e:  # pragma: no cover
            tty.die(e.args[0])
            return ""


class Namespace(object):
    def __init__(self, **kwds):
        for (key, val) in kwds.items():
            self.set(key, val)

    def __str__(self):  # pragma: no cover
        return "Namespace({0})".format(self.joined(", "))

    def joined(self, sep):
        return sep.join("{0}={1!r}".format(*_) for _ in self.__dict__.items())

    def set(self, key, value):
        setattr(self, key, value)

    def as_dict(self):
        return dict(self.__dict__)

    def set_defaults(self, *args):
        for arg in args:
            self.set(arg.dest, arg.default)


class ModuleOption:
    def __init__(self, name, dest=None, default=None, keys=None, help=None, type=str):
        self.name = name
        self.dest = dest or name
        self.default = default
        self.keys = keys or [name]
        self.help = help
        self.type = type


def Boolean(value):
    if value.lower() in ("false", "0", "off"):
        value = False
    elif value.lower() in ("true", "1", "on"):
        value = True
    else:
        value = None
    return value


class TCLSHNotFoundError(Exception):
    pass
import re
from modulecmd.util.lang import split


class MetaData:
    def __init__(self):
        """Store meta data for module"""
        self.enable_if = True

    @property
    def is_enabled(self):
        return self.enable_if

    def parse(self, filename):
        """Reads meta data for module in ``filename``
        # modulecmd: [enable_if=<bool expr>]
        """
        regex = re.compile(r"#\s*modulecmd\:")
        head = open(filename).readline()
        if not regex.search(head):
            return
        modulecmd_directive = split(regex.split(head, 1)[1], ",")
        kwds = dict([split(x, "=", 1) for x in modulecmd_directive])
        for (key, default) in vars(self).items():
            expr = kwds.pop(key, None)
            if expr is None:
                value = default
            else:
                value = eval_bool_expr(expr)
                if value is None:
                    raise MetaDataValueError(expr, filename)
            setattr(self, key, value)

        if len(kwds):
            raise MetaDataUnknownFieldsError(list(kwds.keys()), filename)


def eval_bool_expr(expr):
    import os, sys  # noqa: F401,E401

    # The above inserts aren't used locally, but might be in the eval below
    try:
        return bool(eval(expr))
    except:  # noqa: E722
        return None


class MetaDataValueError(Exception):
    def __init__(self, expr, filename):
        superini = super(MetaDataValueError, self).__init__
        superini(
            "Failed to evaluate meta data statement {0!r} "
            "in {1}".format(expr, filename)
        )


class MetaDataUnknownFieldsError(Exception):
    def __init__(self, fields, filename):
        superini = super(MetaDataUnknownFieldsError, self).__init__
        superini(
            "Unknown MetaData fields {0!r} in module file "
            "{1}".format(", ".join(fields), filename)
        )
import os
import glob
import json
import time
import atexit
import random
from llnl.util.lang import Singleton
from modulecmd.util.lang import get_processes

import modulecmd.paths
import modulecmd.names


class Session:
    def __init__(self):
        id = random.randint(10000, 99999)
        self.id = id
        self.savedir = os.path.join(modulecmd.paths.user_cache_path, "sessions")
        if not os.path.isdir(self.savedir):
            os.makedirs(self.savedir)
        self.filename = os.path.join(self.savedir, "{0}.json".format(self.id))
        self.data = self.load()

    def load(self):
        if not os.path.isfile(self.filename):
            return {}
        with open(self.filename) as fh:
            return json.load(fh)

    def dump(self):
        with open(self.filename, "w") as fh:
            json.dump(self.data, fh, indent=4)

    def save(self, **kwds):
        for (key, val) in kwds.items():
            self.data[key] = val

    def get(self, key):
        return self.data.get(key)

    def remove(self, key):
        self.data.pop(key, None)


def clean():
    # Remove session files more than 7 days old
    now = time.time()
    dirname = session.savedir
    for filename in glob.glob(os.path.join(session.savedir, "*.json")):
        modified_time = os.stat(filename).st_mtime
        if modified_time < now - 7 * 24 * 60 * 60:
            os.remove(filename)


session = Singleton(Session)


def save(**kwds):
    return session.save(**kwds)


def get(key):
    return session.get(key)


def load():
    return session.data


def dump():
    session.dump()


def id():
    return session.id()


def remove(key):
    session.remove(key)


atexit.register(dump)
import os
import json
import atexit

import modulecmd.names
import modulecmd.modulepath

import llnl.util.tty as tty
from llnl.util.lang import Singleton


cache_version_info = (0, 1, 0)


def modifies_cache(fun):
    from functools import wraps

    @wraps(fun)
    def inner(self, *args, **kwargs):
        returnvalue = fun(self, *args, **kwargs)
        self.modified = True
        return returnvalue

    return inner


class Cache:
    def __init__(self, filename):
        self._modified = False
        self.filename = filename
        self._data = None

    @property
    def data(self):
        if self._data is None:
            self._data = self.load()
            version = tuple(self._data.get("version", []))
            if self._data and version != cache_version_info:  # pragma: no cover
                # Old version, forget it
                self._data = {}
                self._modified = True
            self._data["version"] = cache_version_info
        return self._data

    @property
    def modified(self):
        return self._modified

    @modified.setter
    def modified(self, arg):
        self._modified = bool(arg)

    def load(self):
        data = dict()
        if os.path.isfile(self.filename):
            try:
                data.update(dict(json.load(open(self.filename))))
            except json.decoder.JSONDecodeError:  # pragma: no cover
                self.remove()
        return data

    def write(self):
        with open(self.filename, "w") as fh:
            json.dump(self.data, fh, indent=2)

    @modifies_cache
    def remove(self):
        tty.info("Removing the MODULEPATH cache")
        if os.path.isfile(self.filename):
            os.remove(self.filename)
        self._data = dict()

    def get(self, section, key, default=None):
        return self.data.setdefault(section, {}).get(key, default)

    @modifies_cache
    def pop(self, section, key, default=None):
        section_data = self.data.setdefault(section, {})
        items = section_data.pop(key, default)
        return items

    @modifies_cache
    def set(self, section, key, item):
        section_data = self.data.setdefault(section, {})
        section_data[key] = item

    def build(self):
        """Build the cache"""
        tty.info("Building the MODULEPATH cache")
        self._data = {}
        self._data["version"] = cache_version_info

        # Build the modulepath cache
        for path in modulecmd.modulepath.walk():
            path.find_modules()
        self.write()


def factory():
    basename = modulecmd.names.cache_file_basename
    filename = modulecmd.paths.join_user(basename, cache=True)
    return Cache(filename)


cache = Singleton(factory)


def modified():
    return cache.modified


def set(section, key, item):
    cache.set(section, key, item)


def get(section, key):
    return cache.get(section, key)


def pop(section, key):
    return cache.pop(section, key)


def write():
    return cache.write()


def build():
    return cache.build()


def remove():
    cache.remove()


def dump_cache_if_modified():  # pragma: no cover
    if cache.modified:
        cache.write()


atexit.register(dump_cache_if_modified)
modulecmd_major_version = 3
modulecmd_minor_version = 0
modulecmd_micro_version = 5
modulecmd_version = "{0}.{1}.{2}".format(
    modulecmd_major_version, modulecmd_minor_version, modulecmd_micro_version
)
modulecmd_version_info = (modulecmd_major_version, modulecmd_minor_version, modulecmd_micro_version)
import sys

modulepath = "MODULEPATH"

loaded_modules = "LOADEDMODULES"
loaded_module_files = "_LMFILES_"
initial_env = "_LMX0_"
loaded_module_cellar = "_LMX1_"
loaded_module_meta = lambda key: "_LMX2_{0}".format(key)
serialized_key = lambda key, i: "{0}_{1}".format(key, i)

tutorial_save_env = "_LMT0_"
tutorial_root_path = "PYMOD_TUTORIAL_ROOT_PATH"

session_id = "PYMOD_SESSION_ID"

sourced_files = "PYMOD_SOURCED_FILES"
loaded_collection = "PYMOD_LOADED_COLLECTION"

family_name = lambda key: "MODULE_FAMILY_{0}".format(key.upper())
family_version = lambda key: "MODULE_FAMILY_{0}_VERSION".format(key.upper())

default_user_collection = "default"

config_file_basename = "config.yaml"

ld_preload = "LD_PRELOAD"
ld_library_path = "LD_LIBRARY_PATH"
platform_ld_library_path = (
    "DYLD_LIBRARY_PATH" if sys.platform == "darwin" else "LD_LIBRARY_PATH"
)
manpath = "MANPATH"

# Files to store collections and clones.  Paths relative to dot_dir.
aliases_file_basename = "aliases.yaml"
collections_file_basename = "collections.json"
clones_file_basename = "clones.json"
user_env_file_basename = "user.py"
cache_file_basename = "cache.json"
import os
import re
import bisect
from six import StringIO

import modulecmd.alias
import modulecmd.names
import modulecmd.module
from modulecmd.modulepath.path import Path

from modulecmd.util.lang import join
from modulecmd.util.itertools import groupby

import llnl.util.tty as tty
from llnl.util.tty.color import colorize
from llnl.util.tty.colify import colified


class Modulepath:
    def __init__(self, directories):
        self.path = []
        for directory in directories:
            path = Path(directory)
            if not path.modules:
                continue
            self.path.append(path)
        self.defaults = {}
        self.assign_defaults()

    def __contains__(self, dirname):
        return dirname in [p.path for p in self.path]

    def __iter__(self):
        return iter(self.path)

    def walk(self, start=0):
        assert start >= 0
        for path in self.path[start:]:
            yield path

    def __len__(self):
        return len(self.path)

    def size(self):
        return len(self)

    def index(self, dirname):
        for (i, path) in enumerate(self.path):
            if path.path == dirname:
                return i
        raise ValueError("{0} not in Modulepath".format(dirname))  # pragma: no cover

    def clear(self):
        for path in self.path[::-1]:
            self.remove_path(path.path)

    @property
    def value(self):
        if not self.path:
            return None
        return join([p.path for p in self.path], os.pathsep)

    def _get(self, key, use_file_modulepath=False):
        """Implementation of `get`"""
        tty.debug(key)
        if os.path.isdir(key) and key in self:
            return self.getby_dirname(key)
        if os.path.isfile(key):
            tty.debug(key)
            module = self.getby_filename(key, use_file_modulepath=use_file_modulepath)
            if module is not None:
                module.acquired_as = module.filename
            return module
        parts = key.split(os.path.sep)
        if len(parts) == 1:
            # with length of 1, it must be a name
            module = self.defaults.get(key)
            if module is not None:
                module.acquired_as = module.name
            return module
        else:
            for path in self.path:
                for module in path.modules:
                    if module.fullname == key:
                        module.acquired_as = key
                        return module
                    elif module.endswith(key):
                        module.acquired_as = key
                        return module
        return None

    def get(self, key, use_file_modulepath=False):
        """Get a module from the available modules using the following rules:

        If `key`:

            1. is a Module, just return it;
            2. is a directory, return all of the modules in that directory;
            3. is a file name, return the module pointed to by the name;
            4. is a module name (with no version info), return the default
               version; and
            5. meets none of the above criteria, the best match will be
               returned. The best match is found by looking through all
               MODULEPATH directories and returning the first module whose
               filename ends with `key`.

        """
        module = self._get(key, use_file_modulepath=use_file_modulepath)
        if module is None:
            # Module has not been found.  Try an alias
            target = modulecmd.alias.get(key)
            if target is not None:
                # It does no harm to append the alias's modulepath. If it is
                # already used, append_path is a null op, it is not already
                # being used, then appending has less side effects than
                # prepending.
                self.append_path(target["modulepath"])
                module = self.getby_filename(target["filename"])
                if module is None:  # pragma: no cover
                    tty.warn(
                        "Alias {0} points to nonexistent target {1}".format(
                            key, target["target"]
                        )
                    )
        return module

    def getby_dirname(self, dirname):
        for path in self:
            if path.path == dirname:
                return path.modules

    def getby_filename(self, filename, use_file_modulepath=False):
        tty.debug(filename)
        filename = os.path.abspath(filename)
        for path in self.path:
            tty.debug(path.path)
            for module in path.modules:
                if filename == module.filename:
                    return module

        if not use_file_modulepath:
            return None

        # This file is not on the MODULEPATH, add it
        modules = self.append_path(os.path.dirname(filename))
        for module in modules:
            if filename == module.filename:
                return module

        # Hmmmm, how did we get this far???
        return None

    def path_modified(self):
        self.assign_defaults()

    def append_path(self, dirname):
        dirname = Path.expand_name(dirname)
        if dirname in self:
            return
        path = Path(dirname)
        if not path.modules:
            tty.verbose("No modules found in {0}".format(path.path))
            return
        self.path.append(path)
        self.path_modified()
        return path.modules

    def prepend_path(self, dirname):
        dirname = Path.expand_name(dirname)
        if dirname in self:
            path = self.path.pop(self.index(dirname))
        else:
            path = Path(dirname)
            if not path.modules:
                return None
        self.path.insert(0, path)
        self.path_modified()
        return path.modules

    def remove_path(self, dirname):
        """Remove `dirname` from the modulepath

        Parameters
        ----------
        dirname : str
            The directory to remove

        Returns
        -------
        modules_in_dir : list of Module
            The modules in the directory that was removed

        """
        dirname = Path.expand_name(dirname)
        if dirname not in self:  # pragma: no cover
            tty.warn("Modulepath: {0!r} is not in modulepath".format(dirname))
            return []

        modules_in_dir = self.getby_dirname(dirname)
        self.path.pop(self.index(dirname))
        self.path_modified()

        return modules_in_dir

    def assign_defaults(self):
        """Assign defaults to modules.
        1. Look for an exact match in all MODULEPATH directories. Pick the
           first match.
        2. If the name doesn't contain a version, look for a marked default in
           the first directory that has one.
        3. Look for the Highest version in all MODULEPATH directories. If there
           are two or more modulefiles with the Highest version then the first one
           in MODULEPATH order will be picked.

        Given a module with multiple versions, the default is the module with
        the highest version across all modules, unless explicitly made the
        default. A module is explicitly made the default by creating a symlink
        to it (in the same directory) named 'default'
        """

        def module_default_sort_key(module):
            sort_key = (
                1 if module.marked_as_default else -1,
                module.version,
                module.variant,
                -self.index(module.modulepath),
            )
            return sort_key

        self.defaults = {}
        grouped = groupby(
            [module for path in self.path for module in path.modules], lambda x: x.name
        )
        for (_, modules) in grouped:
            for module in modules:
                module.is_default = False
            if len(modules) > 1:
                modules = sorted(modules, key=module_default_sort_key, reverse=True)
                modules[0].is_default = True
            self.defaults[modules[0].name] = modules[0]

    def filter_modules_by_regex(self, modules, regex):
        if regex:
            modules = [m for m in modules if re.search(regex, m.fullname)]
        return modules

    def colorize(self, string):
        """Colorize item for output to console"""
        D = "(%s)" % colorize("@R{D}")
        L = "(%s)" % colorize("@G{L}")
        DL = "(%s,%s)" % (colorize("@R{D}"), colorize("@G{L}"))
        colorized = string.replace("(D)", D)
        colorized = colorized.replace("(L)", L)
        colorized = colorized.replace("(D,L)", DL)
        return colorized

    @staticmethod
    def sort_key(module):
        return (module.name, module.version)

    def avail(self, terse=False, regex=None, long_format=False):
        if terse:
            return self.avail_terse(regex=regex)
        else:
            return self.avail_full(regex=regex, long_format=long_format)

    def avail_full(self, regex=None, long_format=False):
        sio = StringIO()
        sio.write("\n")
        _, width = tty.terminal_size()
        # head = lambda x: (" " + x + " ").center(width, "-")
        for path in self:
            directory = path.path
            modules = sorted(
                [m for m in path.modules if m.is_enabled], key=self.sort_key
            )
            modules = self.filter_modules_by_regex(modules, regex)
            if not os.path.isdir(directory):  # pragma: no cover
                s = colorize("@r{(Directory not readable)}".center(width))
            elif not modules:  # pragma: no cover
                if regex:
                    continue
                s = colorize("@r{(None)}".center(width))
            else:
                modules = [self.colorize(m.format_dl_status()) for m in modules]
                aliases = modulecmd.alias.get(directory)
                if aliases:  # pragma: no cover
                    for (alias, target) in aliases:
                        i = bisect.bisect_left(modules, alias)
                        insert_key = colorize("@M{%s}@@" % (alias))
                        if long_format:  # pragma: no cover
                            insert_key += " -> %s" % (target)
                        modules.insert(i, insert_key)
                s = colified(modules, width=width)
            directory = directory.replace(os.path.expanduser("~/"), "~/")
            # sio.write(head(directory) + '\n')
            sio.write(colorize("@G{%s}:\n" % (directory)))
            sio.write(s + "\n")
        return sio.getvalue()

    def avail_terse(self, regex=None):
        sio = StringIO()
        for path in self:
            directory = path.path
            modules = path.modules
            if not os.path.isdir(directory):  # pragma: no cover
                continue
            modules = sorted([m for m in modules if m.is_enabled], key=self.sort_key)
            modules = self.filter_modules_by_regex(modules, regex)
            if not modules:  # pragma: no cover
                continue
            sio.write(directory + ":\n")
            sio.write("\n".join(m.fullname for m in modules))
        sio.write("\n")
        return sio.getvalue()

    def candidates(self, key):
        # Return a list of modules that might by given by key
        the_candidates = []
        for path in self:
            if not path.modules:  # pragma: no cover
                continue
            for module in path.modules:
                if module.name.endswith(key):
                    the_candidates.append(module)  # pragma: no cover
                elif module.fullname.endswith(key):
                    the_candidates.append(module)  # pragma: no cover
                else:
                    f = module.filename
                    if not isinstance(module, modulecmd.module.TclModule):
                        f = os.path.splitext(f)[0]
                    if f.endswith(key):  # pragma: no cover
                        the_candidates.append(module)
        return the_candidates
import os

import modulecmd.module
import modulecmd.environ

import llnl.util.tty as tty
from llnl.util.filesystem import working_dir

"""Functions for finding modules on MODULEPATH"""

marked_default_names = ("default", ".version")
skip_dirs = (".git", ".svn", "CVS")


def find_modules(directory):

    directory = os.path.expanduser(directory)

    if directory == "/":
        tty.verbose("Requesting to find modules in root directory")
        return None

    if not os.access(directory, os.R_OK):
        tty.verbose("{0!r} is not an accessible directory".format(directory))
        return None

    if not os.path.isdir(directory):  # pragma: no cover
        # This should be redundant because of the previous check
        tty.verbose("{0!r} is not a directory".format(directory))
        return None

    return _find(directory)


def _find(directory):

    defaults = {}
    dir_modules = {}
    directory = os.path.abspath(directory)

    for (dirname, dirs, files) in os.walk(directory):

        if os.path.basename(dirname) in skip_dirs:
            del dirs[:]
            continue

        explicit_default = pop_marked_default(dirname, files)
        if explicit_default is not None:
            key = dirname.replace(directory + os.path.sep, "")
            defaults[key] = explicit_default

        modulefiles = []
        for basename in files:
            if basename.startswith("."):
                continue
            f = os.path.join(dirname, basename)
            path = f.replace(directory + os.path.sep, "")
            module = modulecmd.module.factory(directory, path)
            if module is None:
                continue
            modulefiles.append(module)

        if not modulefiles:
            continue

        for module in modulefiles:
            dir_modules.setdefault(module.name, []).append(module)

    mark_explicit_defaults(dir_modules, defaults)
    modules = [m for (_, modules) in dir_modules.items() for m in modules] or None
    return modules


def mark_explicit_defaults(modules, defaults):
    for (name, filename) in defaults.items():
        mods = modules.get(name)
        if mods is None:
            tty.debug("There is no module named {0}".format(name))
            continue
        for module in mods:
            if os.path.realpath(module.filename) == os.path.realpath(filename):
                module.marked_as_default = True
                break
        else:
            tty.verbose("No matching module to mark default for {0}".format(name))


def pop_marked_default(dirname, versions):
    dirname = os.path.realpath(dirname)
    assert os.path.isdir(dirname)
    linked_default = pop_linked_default(dirname, versions)
    versioned_default = pop_versioned_default(dirname, versions)
    if linked_default and versioned_default:
        tty.verbose(
            "A linked and versioned default exist in {0}, "
            "choosing the linked".format(dirname)
        )
        return linked_default
    return linked_default or versioned_default


def pop_linked_default(dirname, files):
    """Look for a file named `default` that is a symlink to a module file"""
    linked_default_name = "default"
    try:
        files.remove(linked_default_name)
    except ValueError:
        return None

    linked_default_file = os.path.join(dirname, linked_default_name)
    if not os.path.islink(linked_default_file):
        tty.verbose(
            "Modulepath: expected file named `default` in {0} "
            "to be a link to a modulefile".format(dirname)
        )
        return None

    linked_default_source = os.path.realpath(linked_default_file)
    if not os.path.dirname(linked_default_source) == dirname:
        tty.verbose(
            "Modulepath: expected file named `default` in {0} to be "
            "a link to a modulefile in the same directory".format(dirname)
        )
        return None

    return linked_default_source


def pop_versioned_default(dirname, files):
    """TCL modules .version scheme"""
    version_file_name = ".version"
    try:
        files.remove(version_file_name)
    except ValueError:
        return None
    version_file = os.path.join(dirname, version_file_name)
    version = read_tcl_default_version(version_file)
    if version is None:
        tty.verbose("Could not determine .version default in {0}".format(dirname))
    else:
        default_file = os.path.join(dirname, version)
        if os.path.exists(default_file):
            return default_file
        tty.verbose("{0!r}: version default does not exist".format(default_file))


def read_tcl_default_version(filename):
    with open(filename) as fh:
        for (i, line) in enumerate(fh.readlines()):
            line = " ".join(line.split())
            if i == 0 and not line.startswith("#%Module"):
                tty.debug("version file does not have #%Module header")
            if line.startswith("set ModulesVersion"):
                raw_version = line.split("#", 1)[0].split()[-1]
                try:
                    version = eval(raw_version)
                except (SyntaxError, NameError):
                    version = raw_version
                return version
    return None


def listdir(dirname):
    files, dirs = [], []
    if not os.access(dirname, os.X_OK):  # pragma: no cover
        return [], []
    with working_dir(dirname):
        for item in os.listdir("."):
            if os.path.isdir(item):
                if item in (".git", ".svn", "CVS"):  # pragma: no cover
                    continue
                dirs.append(item)
            else:
                files.append(item)
    return files, dirs


def isfilelike(item):
    return os.path.exists(item) and not os.path.isdir(item)
import os

import modulecmd.names
from modulecmd.modulepath.modulepath import Modulepath
from modulecmd.modulepath.discover import find_modules

from modulecmd.util.lang import split
from llnl.util.lang import Singleton


def factory():  # pragma: no cover
    path = split(os.getenv(modulecmd.names.modulepath), os.pathsep)
    return Modulepath(path)


_path = Singleton(factory)


def path():
    return [p.path for p in _path.path]


def set_path(other_path):
    global _path
    _path = other_path


def get(key, use_file_modulepath=False):
    return _path.get(key, use_file_modulepath=use_file_modulepath)


def append_path(dirname):
    return _path.append_path(dirname)


def remove_path(dirname):
    return _path.remove_path(dirname)


def prepend_path(dirname):
    return _path.prepend_path(dirname)


def avail(**kwargs):
    return _path.avail(**kwargs)


def candidates(name):
    return _path.candidates(name)


def contains(path):
    return path in _path


def walk(start=0):
    return _path.walk(start=0)


def size():
    return _path.size()


def clear():
    return _path.clear()
import os
from string import Template
import modulecmd.cache
import modulecmd.names
import modulecmd.config
import modulecmd.module
from modulecmd.modulepath.discover import find_modules


class Path:
    """Class to hold modules in a directory"""

    def __init__(self, dirname):
        self.path = self.expand_name(dirname)
        self.modules = self.find_modules()

    def find_modules(self):
        cached_modules = self.get_cached_modules()
        if cached_modules is not None:
            return cached_modules
        else:
            modules = find_modules(self.path)
            if modules:
                self.cache_modules(modules)
            return modules

    def get_cached_modules(self):
        if not modulecmd.config.get("use_modulepath_cache"):  # pragma: no cover
            return None
        key = self.path
        section = modulecmd.names.modulepath
        cached = modulecmd.cache.get(section, key)
        if cached is None:
            return None

        modules = [modulecmd.module.from_dict(m) for m in cached]
        if any([m is None for m in modules]):
            # A module was removed, the cache is invalid
            modulecmd.cache.pop(section, key)
            return None
        return modules

    def cache_modules(self, modules):
        if not modulecmd.config.get("use_modulepath_cache"):  # pragma: no cover
            return
        key = self.path
        section = modulecmd.names.modulepath
        data = [modulecmd.module.as_dict(m) for m in modules]
        modulecmd.cache.set(section, key, data)

    @classmethod
    def expand_name(cls, dirname):
        return os.path.expanduser(Template(dirname).safe_substitute(**(os.environ)))
import os
import re
import sys
import json
from six import StringIO
from ordereddict_backport import OrderedDict

import modulecmd.system
import modulecmd.error
import modulecmd.names
import modulecmd.paths
import modulecmd.compat
import modulecmd.environ

import llnl.util.tty as tty
from llnl.util.tty import terminal_size
from llnl.util.tty.color import colorize
from llnl.util.tty.colify import colified
from llnl.util.lang import Singleton


class Collections:
    """Manages a collection of modules"""

    version = (1, 0)

    def __init__(self, filename):
        self.filename = filename
        self._data = None

    def __contains__(self, collection_name):
        return collection_name in self.data

    @property
    def data(self):
        if self._data is None:
            self._data = self.read(self.filename)
        return self._data

    def read(self, filename):
        if os.path.isfile(filename):
            obj = dict(json.load(open(filename)))
            version = obj.get("Version")
            version = version if version is None else tuple(version)
            if version != Collections.version:  # pragma: no cover
                return modulecmd.compat.collection.upgrade(self, obj, version)
            else:
                return dict(obj["Collections"])
        return dict()

    def write(self, collections, filename):
        obj = {"Version": self.version, "Collections": collections}
        if modulecmd.config.get("dryrun"):  # pragma: no cover
            sys.stderr.write(json.dumps(obj))
        else:
            with open(filename, "w") as fh:
                json.dump(obj, fh, indent=2)
        return

    def save(self, name, modules):
        collection = OrderedDict()
        for module in modules:
            ar = module.asdict()
            ar["refcount"] = 0
            collection.setdefault(module.modulepath, []).append(ar)
        collection = list(collection.items())
        self.data.update({name: collection})
        self.write(self.data, self.filename)
        return None

    def get(self, name):
        return self.data.get(name)

    def remove(self, name):
        self.data.pop(name, None)
        self.write(self.data, self.filename)

    def add_to_loaded_collection(self, name):
        """Add a module `name` to the currently loaded collection"""
        collection_name = modulecmd.environ.get(modulecmd.names.loaded_collection)
        if collection_name is None:  # pragma: no cover
            tty.die("There is no collection currently loaded")
        data = OrderedDict(self.data.pop(collection_name))
        module = modulecmd.modulepath.get(name)
        if module is None:
            raise modulecmd.error.ModuleNotFoundError(name)
        if not module.is_loaded:
            modulecmd.system.load_impl(module)
        for (mp, modules) in data.items():
            if mp != module.modulepath:
                continue
            for other in modules:
                if other["fullname"] == module.fullname:  # pragma: no cover
                    tty.warn(
                        "{0} is already in collection {1}".format(name, collection_name)
                    )
                    return
        ar = module.asdict()
        ar["refcount"] = 0
        data.setdefault(module.modulepath, []).append(ar)
        data = list(data.items())
        self.data.update({collection_name: data})
        self.write(self.data, self.filename)
        return None

    def pop_from_loaded_collection(self, name):
        """Remove a module `name` to the currently loaded collection"""
        collection_name = modulecmd.environ.get(modulecmd.names.loaded_collection)
        if collection_name is None:
            tty.die("There is no collection currently loaded")  # pragma: no cover
        data = OrderedDict(self.data.pop(collection_name))
        module = modulecmd.modulepath.get(name)
        if module is None:  # pragma: no cover
            raise modulecmd.error.ModuleNotFoundError(name)
        if module.is_loaded:
            modulecmd.system.unload_impl(module)
        for (mp, modules) in data.items():
            if mp != module.modulepath:  # pragma: no cover
                continue
            data[mp] = [
                other for other in modules if other["fullname"] == module.fullname
            ]
            break
        data = list(data.items())
        self.data.update({collection_name: data})
        self.write(self.data, self.filename)
        return None

    def filter_collections_by_regex(self, collections, regex):
        if regex:
            collections = [c for c in collections if re.search(regex, c)]
        return collections

    def avail(self, terse=False, regex=None):
        skip = (modulecmd.names.default_user_collection,)
        names = sorted([x for x in self.data if x not in skip])

        if regex:
            names = self.filter_collections_by_regex(names, regex)

        if not names:  # pragma: no cover
            return ""

        sio = StringIO()
        if not terse:
            _, width = terminal_size()
            s = colified(names, width=width)
            # sio.write('{0}\n{1}\n'
            #          .format(' Saved collections '.center(width, '-'), s))
            sio.write(colorize("@G{Saved collections}:\n%s\n" % (s)))
        else:
            sio.write("\n".join(c for c in names))
        string = sio.getvalue()
        return string

    def show(self, name):
        """Show the high-level commands executed by

            module show <collection>
        """
        collection = self.get(name)
        if collection is None:  # pragma: no cover
            tty.warning("{0!r} is not a collection".format(name))
            return

        sio = StringIO()
        loaded_modules = modulecmd.system.loaded_modules()
        for m in loaded_modules[::-1]:
            sio.write("unload({0!r})\n".format(m.fullname))

        for (directory, archives) in collection:
            sio.write("use({0!r})\n".format(directory))
            for ar in archives:
                name = ar["fullname"]
                opts = ar["opts"]
                if opts:
                    opts_string = modulecmd.module.Namespace(**opts).joined(" ")
                    s = "load({0!r}, options={1!r})".format(name, opts_string)
                else:
                    s = "load({0!r})".format(name)
                sio.write(s + "\n")

        return sio.getvalue()


def factory():
    basename = modulecmd.names.collections_file_basename
    filename = modulecmd.paths.join_user(basename, cache=True)
    return Collections(filename)


collections = Singleton(factory)


def save(name, loaded_modules):
    return collections.save(name, loaded_modules)


def remove(name):
    return collections.remove(name)


def pop_from_loaded_collection(name):
    return collections.pop_from_loaded_collection(name)


def add_to_loaded_collection(name):
    return collections.add_to_loaded_collection(name)


def get(name):
    return collections.get(name)


def avail(terse=False, regex=None):
    return collections.avail(terse=terse, regex=regex)


def show(name):
    return collections.show(name)


def contains(name):
    return name in collections


def version():
    return Collections.version
import os
import re
import inspect
import textwrap
from six import StringIO
from argparse import ArgumentParser
from ordereddict_backport import OrderedDict

import modulecmd.paths
import modulecmd.callback

category_descriptions = OrderedDict(
    environment="Functions for modifying the environment",
    path="Functions for modifying path-like variables",
    alias="Functions for defining shell aliases and functions",
    module="General module functions",
    interaction="Functions for interacting with other modules",
    family="Functions for interacting with module families",
    modulepath="Functions for interacting with the MODULEPATH",
    info="Functions for relaying information",
    utility="General purpose utilities",
)


def fill_with_paragraphs(string, indent=""):
    filled = []
    lines = []
    for line in string.split("\n"):
        if line.split():
            lines.append(line)
        elif lines:
            filled.append(
                textwrap.fill(
                    "\n".join(lines),
                    width=80,
                    initial_indent=indent,
                    subsequent_indent=indent,
                )
                + "\n"
            )
            lines = []
    if lines:
        filled.append(
            textwrap.fill(
                "\n".join(lines),
                width=80,
                initial_indent=indent,
                subsequent_indent=indent,
            )
            + "\n"
        )
    return "\n".join(filled)


class Callback:
    section_re = re.compile("(?i)^(argument|keyword argument|return|note|example)[s]:")

    def __init__(self, name):
        self.name = name
        self.obj = modulecmd.callback.get_callback(name)
        self.raw_doc = inspect.getdoc(self.obj)
        self._description = None

        self.parse_docstring()

    def parse_docstring(self):
        self._description = self._parse_description()
        self._param_names = self._parse_signature()
        self._args = self._parse_args_description()
        self._kwargs = self._parse_kwargs_description()
        self._returns = self._parse_returns_description()
        self._notes = self._get_section("note")
        self._examples = self._get_section("example")

    def _parse_description(self):
        description = ""
        for line in self.raw_doc.split("\n"):
            if self.section_re.search(line):
                break
            description += line
        if description.split():
            return " ".join(description.split())

    def _parse_signature(self):
        param_names = []
        sig = inspect.signature(self.obj)
        for (i, param) in enumerate(sig.parameters.values()):
            param_name = str(param)
            if i == 0:
                if param_name != "module":
                    raise ValueError(
                        "Expected first parameter of {0} to be 'module', "
                        "got {1}".format(self.name, param)
                    )
            elif i == 1:
                if param_name != "mode":
                    raise ValueError(
                        "Expected first parameter of {0} to be 'mode', "
                        "got {1}".format(self.name, param)
                    )
            else:
                param_names.append(param_name)
        return param_names

    def _parse_args_description(self):
        args = []
        in_section = 0
        regex = re.compile("(\w+)\s+\(([a-zA-Z0-9-_ ]+)\)")
        for line in self.raw_doc.split("\n"):
            if not line.split():
                continue
            if self.section_re.search(line):
                if line.lower().startswith("argument"):
                    in_section = 1
                    continue
                in_section = 0
                continue
            if in_section:
                name_and_type, _, description = line.partition(":")
                result = regex.search(name_and_type)
                if result is None:
                    raise ValueError(
                        "Expected parameter {0} to be of form "
                        "<name (type)>".format(name_and_type)
                    )
                name, type = result.groups()
                if name in ("module", "mode"):
                    continue
                if (
                    name not in self._param_names
                    and "*" + name not in self._param_names
                ):
                    raise ValueError(
                        "{2}: parameter {0} not in {1}".format(
                            name, self._param_names, self.name
                        )
                    )
                args.append((name, type, " ".join(description.split())))
        if args:
            return args

    def _parse_kwargs_description(self):
        kwargs = []
        in_section = 0
        regex = re.compile("(\w+)\s+\(([a-zA-Z0-9-_ ]+)\)")
        for line in self.raw_doc.split("\n"):
            if not line.split():
                continue
            if self.section_re.search(line):
                if line.lower().startswith("keyword argument"):
                    in_section = 1
                    continue
                in_section = 0
                continue
            if in_section:
                name_and_type, _, description = line.partition(":")
                result = regex.search(name_and_type)
                if result is None:
                    raise ValueError(
                        "Expected parameter {0} to be of form "
                        "<name (type)>".format(name_and_type)
                    )
                name, type = result.groups()
                kwargs.append((name, type, " ".join(description.split())))
        if kwargs:
            return kwargs

    def _parse_returns_description(self):
        returns = []
        in_section = 0
        regex = re.compile("(\w+)\s+\(([a-zA-Z0-9-_ ]+)\)")
        for line in self.raw_doc.split("\n"):
            if not line.split():
                continue
            if self.section_re.search(line):
                if line.lower().startswith("return"):
                    in_section = 1
                    continue
                in_section = 0
                continue
            if in_section:
                name_and_type, _, description = line.partition(":")
                result = regex.search(name_and_type)
                if result is None:
                    raise ValueError(
                        "{0}: expected parameter {1} to be of form "
                        "<name (type)>".format(self.name, name_and_type)
                    )
                name, type = result.groups()
                returns.append((name, type, " ".join(description.split())))
        if returns:
            return returns

    def _get_section(self, section):
        content = []
        in_section = 0
        #  regex = re.compile("(\w+)\s+\(([a-zA-Z0-9-_ ]+)\)")
        for line in self.raw_doc.split("\n"):
            if self.section_re.search(line):
                if line.lower().startswith(section):
                    in_section = 1
                    continue
                in_section = 0
                continue
            if in_section:
                content.append(line)
        if content:
            return "\n".join(content)

    def documentation(self, indent="    "):
        params = ", ".join(x.replace("*", "\*") for x in self._param_names)
        s = ["**{0}**\ *({1})*".format(self.name, params)]

        s.append("\n{0}{1}".format(indent, self._description))

        if self._args:
            s.append("\n{0}**Arguments**\n".format(indent))
            for (name, type, description) in self._args:
                s.append(
                    "{0}*{1}* ({2}): {3}\n".format(indent, name, type, description)
                )

        if self._kwargs:
            s.append("\n{0}**Keyword arguments**\n".format(indent))
            for (name, type, description) in self._kwargs:
                s.append(
                    "{0}*{1}* ({2}): {3}\n".format(indent, name, type, description)
                )

        if self._returns:
            s.append("\n{0}**Returns**\n".format(indent))
            for (name, type, description) in self._returns:
                s.append(
                    "{0}*{1}* ({2}): {3}\n".format(indent, name, type, description)
                )

        if self._notes:
            s.append("\n{0}**Notes**\n".format(indent))
            s.append(
                "\n".join("{0}{1}".format(indent, x) for x in self._notes.split("\n"))
            )

        if self._examples:
            s.append("\n{0}**Examples**\n".format(indent))
            s.append(
                "\n".join(
                    "{0}{1}".format(indent, x) for x in self._examples.split("\n")
                )
            )

        return "\n".join(s)


def gen_callback_docs():

    callbacks = {}
    for name in modulecmd.callback.all_callbacks():
        m = modulecmd.callback.get_module(name)
        cb = Callback(name)
        assert m.category in category_descriptions
        callbacks.setdefault(m.category, []).append(cb)

    sio = StringIO()
    for (category, description) in category_descriptions.items():
        description = category_descriptions[category]
        sio.write("\n" + "^" * len(description) + "\n")
        sio.write(description + "\n")
        sio.write("^" * len(description) + "\n\n")

        for cb in callbacks[category]:
            sio.write(cb.documentation(indent="    ") + "\n")
            sio.write("\n")

    template = open(os.path.join(modulecmd.paths.docs_path, "modulefile.rst.in")).read()
    output = template % {"commands": sio.getvalue()}
    with open(os.path.join(modulecmd.paths.docs_path, "modulefile.rst"), "w") as fh:
        fh.write(output)


def main():
    p = ArgumentParser()
    p.add_argument("what", choices=("callbacks",))
    args = p.parse_args()

    if args.what == "callbacks":
        gen_callback_docs()
import modulecmd.system

description = "Save loaded modules"
level = "short"
section = "collections"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument(
        "name",
        nargs="?",
        default=modulecmd.names.default_user_collection,
        help="Name of collection to save",
    )


#    subparser.add_argument(
#        '--local', action='store_true', default=False,
#        help='Save the collection locally')


def save(parser, args):
    modulecmd.system.save_collection(args.name)  # , local=args.local)
import os
import modulecmd.paths
from modulecmd.util.tty.pager import pager
from modulecmd.util.tty import redirect_stdout

try:
    import docutils
except ImportError:  # pragma: no cover
    docutils = None

try:
    from docutils import nodes, core  # noqa: F401
except ImportError:  # pragma: no cover
    docutils = -1


description = "Display Modulecmd.py guides in the console"
section = "info"
level = "short"


available_guides = dict(
    [
        (os.path.splitext(f)[0], os.path.join(modulecmd.paths.docs_path, f))
        for f in os.listdir(modulecmd.paths.docs_path)
    ]
)


def setup_parser(subparser):
    subparser.add_argument(
        "guide", choices=available_guides, help="Name of guide to display"
    )


def guide(parser, args):
    if docutils is None:  # pragma: no cover
        raise ImportError("Guides require docutils module")
    elif docutils == -1:  # pragma: no cover
        msg = (
            "There was an error importing several docutils components and "
            "the guides cannot be displayed"
        )
        raise ImportError(msg)
    import rst2ansi

    filename = available_guides[args.guide]
    with redirect_stdout():
        pager(rst2ansi.rst2ansi(open(filename, "r").read()))
import os
import argparse

import modulecmd.system
from modulecmd.command.common import parse_module_options

description = "Show the commands that would be issued by module load"
level = "short"
section = "info"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument(
        "-i",
        "--insert-at",
        type=int,
        default=None,
        help="Load the module as the `i`th module.",
    )
    subparser.add_argument(
        "args",
        nargs=argparse.REMAINDER,
        help=(
            "Modules and options to load. Additional options can be sent \n"
            "directly to the module using the syntax, `+option[=value]`. \n"
            "See the module options help for more details."
        ),
    )


def show(parser, args):
    argv = parse_module_options(args.args)
    for (i, spec) in enumerate(argv):
        insert_at = args.insert_at if i == 0 else None
        name = (
            spec["name"]
            if spec["version"] is None
            else os.path.sep.join([spec["name"], spec["version"]])
        )
        modulecmd.system.show(name, opts=spec["options"], insert_at=insert_at)
import sys
import modulecmd.alias
import modulecmd.modulepath
from modulecmd.error import ModuleNotFoundError

description = "Create an alias to a module"
level = "short"
section = "basic"


_subcommands = {}


def add_avail_command(parser):
    def avail(args):
        s = modulecmd.alias.avail(terse=args.terse)
        sys.stderr.write(s)

    p = parser.add_parser("avail", help="List saved aliases")
    p.add_argument(
        "-t",
        "--terse",
        action="store_true",
        default=False,
        help="Display output in terse format [default: %(default)s]",
    )
    _subcommands["avail"] = avail


def add_save_command(parser):
    def save(args):
        target = modulecmd.modulepath.get(args.target)
        if target is None:
            raise ModuleNotFoundError(args.target)
        modulecmd.alias.save(target, args.alias_name)

    p = parser.add_parser("save", help="Save the current environment")
    p.add_argument("target", help="Name of module to alias")
    p.add_argument("alias_name", help="Name of alias")
    _subcommands["save"] = save


def add_remove_command(parser):
    def remove(args):
        return modulecmd.alias.remove(args.name)

    p = parser.add_parser("remove", help="Remove alias")
    p.add_argument("name", help="Name of alias to remove")
    _subcommands["remove"] = remove


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    sp = subparser.add_subparsers(metavar="SUBCOMMAND", dest="subcommand")
    add_avail_command(sp)
    add_save_command(sp)
    add_remove_command(sp)


def alias(parser, args):
    _subcommands[args.subcommand](args)
import modulecmd.system
import modulecmd.shell
import modulecmd.modulepath


description = "Add (use) directory[s] to MODULEPATH"
level = "short"
section = "modulepath"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument("path", help="Path[s] to use.")
    subparser.add_argument(
        "-a",
        "--append",
        default=False,
        action="store_true",
        help="Append path[s] to MODULEPATH, otherwise prepend",
    )
    subparser.add_argument(
        "-D",
        "--delete",
        default=False,
        action="store_true",
        help=(
            "Remove path[s] from MODULEPATH instead of adding. "
            "Behaves identically to `unuse`"
        ),
    )


def use(parser, args):
    modulecmd.system.use(args.path, delete=args.delete, append=args.append)
    modulecmd.system.dump()
import sys
import modulecmd.system

description = "Display loaded modules"
level = "short"
section = "info"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument(
        "regex", nargs="?", help="Regular expression to highlight in the output"
    )
    subparser.add_argument(
        "-t",
        "--terse",
        default=False,
        action="store_true",
        help="Display output in terse format",
    )
    subparser.add_argument(
        "-c",
        "--show-command",
        default=False,
        action="store_true",
        help="Display commands to load necessary to load the loaded modules",
    )


def list(parser, args):
    s = modulecmd.system.list(
        terse=args.terse, show_command=args.show_command, regex=args.regex
    )
    sys.stderr.write(s)
import sys
import modulecmd.paths

description = "Show Modulecmd.py paths"
level = "short"
section = "developer"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    pass


def add_path(a, name):
    path = getattr(modulecmd.paths, name)
    key = " ".join(name.split("_"))
    a.append((key, path))


def paths(parser, args):
    a = []
    add_path(a, "prefix")
    add_path(a, "user_config_path")
    n = max([len(x[0]) for x in a]) + 1
    for (name, path) in a:
        sys.stderr.write("{0:{1}s} {2}\n".format(name + ":", n, path))
import modulecmd.tutorial
import llnl.util.tty as tty

description = "Setup or teardown Modulecmd.py's mock tutorial MODULEPATH"
section = "basic"
level = "short"


def setup_parser(subparser):
    subparser.add_argument(
        "action",
        choices=("basic", "teardown"),
        help="Setup or teardown Modulecmd.py's mock tutorial MODULEPATH",
    )


def tutorial(parser, args):
    if args.action == "basic":
        tty.info("Setting up Modulecmd.py's basic mock tutorial MODULEPATH")
        modulecmd.tutorial.basic_usage()
    elif args.action == "teardown":
        tty.info("Removing Modulecmd.py's mock tutorial MODULEPATH")
        modulecmd.tutorial.teardown()
    modulecmd.system.dump()
import modulecmd.system

description = "Reload a loaded module"
level = "short"
section = "basic"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument("name", help="Module to reload")


def reload(parser, args):
    modulecmd.system.reload(args.name)
    modulecmd.system.dump()
import modulecmd.system

description = (
    "Swaps two modules, effectively unloading the first " "then loading the second"
)
level = "short"
section = "basic"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument("first", help="Module to unload")
    subparser.add_argument("second", help="Module to load")


def swap(parser, args):
    modulecmd.system.swap(args.first, args.second)
    modulecmd.system.dump()
import modulecmd.system

description = "Print contents of a module or collection to the console output."
level = "short"
section = "info"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument("name", help="Name of module, collection, or config file")


def cat(parser, args):
    modulecmd.system.cat(args.name)
import modulecmd.system

description = "Reset environment to initial state"
level = "short"
section = "basic"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """


def reset(parser, args):
    modulecmd.system.reset()
    modulecmd.system.dump()
import modulecmd.system

description = "Remove saved collection of modules"
level = "short"
section = "collections"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument("name", help="Name of collection to remove")


def remove(parser, args):
    modulecmd.system.remove_collection(args.name)
import argparse
import modulecmd.system

description = "Unload modules from environment"
level = "short"
section = "basic"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument("names", nargs=argparse.REMAINDER, help="Modules to unload")


def unload(parser, args):
    for name in args.names:
        modulecmd.system.unload(name)
    modulecmd.system.dump()
import modulecmd.cache

description = "Cache modules"
level = "short"
section = "basic"


_subcommands = {}


def add_build_command(parser):
    def build(args):
        modulecmd.cache.build()

    parser.add_parser("build", help="Build the module cache")
    _subcommands["build"] = build


def add_rebuild_command(parser):
    def rebuild(args):
        modulecmd.cache.remove()
        modulecmd.cache.build()

    parser.add_parser("rebuild", help="Rebuild the module cache")
    _subcommands["rebuild"] = rebuild


def add_remove_command(parser):
    def remove(args):
        modulecmd.cache.remove()

    parser.add_parser("remove", help="Remove the module cache")
    _subcommands["remove"] = remove


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    sp = subparser.add_subparsers(metavar="SUBCOMMAND", dest="subcommand")
    add_build_command(sp)
    add_remove_command(sp)
    add_rebuild_command(sp)


def cache(parser, args):
    _subcommands[args.subcommand](args)
# File adapted from spack/cmd/__init__.py

from __future__ import print_function

import os
import re

from llnl.util.lang import attr_setdefault
import llnl.util.tty as tty

import modulecmd.config
import modulecmd.paths


# command has a submodule called "list" so preserve the python list module
python_list = list

# Patterns to ignore in the commands directory when looking for commands.
ignore_files = r"^\.|^__init__.py$|^#|flycheck_"

SETUP_PARSER = "setup_parser"
DESCRIPTION = "description"


def python_name(cmd_name):
    """Convert ``-`` to ``_`` in command name, to make a valid identifier."""
    return cmd_name.replace("-", "_")


def cmd_name(python_name):
    """Convert module name (with ``_``) to command name (with ``-``)."""
    return python_name.replace("_", "-")


#: global, cached list of all commands -- access through all_commands()
_all_commands = None


def all_commands():
    """Get a sorted list of all modulecmd commands.

    This will list the lib/modulecmd/modulecmd/command directory and find the
    commands there to construct the list.  It does not actually import
    the python files -- just gets the names.
    """
    global _all_commands
    if _all_commands is None:
        _all_commands = []
        command_paths = [modulecmd.paths.command_path]  # Built-in commands
        for path in command_paths:
            for file in os.listdir(path):
                if file.endswith(".py") and not re.search(ignore_files, file):
                    command = re.sub(r".py$", "", file)
                    _all_commands.append(cmd_name(command))

        _all_commands.sort()

    return _all_commands


def get_module(cmd_name):
    """Imports the module for a particular command name and returns it.

    Parameters
    ----------
    cmd_name : str
        name of the command for which to get a module (contains ``-``, not ``_``).
    """
    pname = python_name(cmd_name)

    # Import the command from the built-in directory
    module_name = "{0}.{1}".format(__name__, pname)
    module = __import__(
        module_name, fromlist=[pname, SETUP_PARSER, DESCRIPTION], level=0
    )
    tty.debug("Imported {0} from built-in commands".format(pname))

    attr_setdefault(module, SETUP_PARSER, lambda *args: None)  # null-op
    attr_setdefault(module, DESCRIPTION, "")

    if not hasattr(module, pname):  # pragma: no cover
        tty.die(
            "Command module {0} ({1}) must define function {2!r}.".format(
                module.__name__, module.__file__, pname
            )
        )

    return module


def get_command(cmd_name):
    """Imports the command's function from a module and returns it.

    Args:
        cmd_name (str): name of the command for which to get a module
            (contains ``-``, not ``_``).
    """
    pname = python_name(cmd_name)
    return getattr(get_module(pname), pname)
import modulecmd.system


description = "Remove all loaded modules"
level = "short"
section = "basic"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument(
        "-F",
        default=None,
        action="store_true",
        help="Do not load modules in `load_after_purge` configuration",
    )


def purge(parser, args):
    modulecmd.system.purge(load_after_purge=not args.F)
    modulecmd.system.dump()
import os
import re
import sys
import argparse
import pytest
from six import StringIO

from llnl.util.filesystem import working_dir
from llnl.util.tty.colify import colify
from modulecmd.util.tty import redirect_stdout2 as redirect_stdout

import modulecmd.paths
import modulecmd.modulepath

description = "run modulecmd's unit tests"
section = "developer"
level = "long"


def setup_parser(subparser):
    subparser.add_argument(
        "-H",
        "--pytest-help",
        action="store_true",
        default=False,
        help="print full pytest help message, showing advanced options",
    )

    list_group = subparser.add_mutually_exclusive_group()
    list_group.add_argument(
        "-l", "--list", action="store_true", default=False, help="list basic test names"
    )
    list_group.add_argument(
        "-L",
        "--long-list",
        action="store_true",
        default=False,
        help="list the entire hierarchy of tests",
    )
    subparser.add_argument(
        "tests",
        nargs=argparse.REMAINDER,
        help="list of tests to run (will be passed to pytest -k)",
    )


def do_list(args, unknown_args):
    """Print a lists of tests than what pytest offers."""
    # Run test collection and get the tree out.
    old_output = sys.stderr
    try:
        sys.stderr = output = StringIO()
        pytest.main(["--collect-only"])
    finally:
        sys.stderr = old_output

    # put the output in a more readable tree format.
    lines = output.getvalue().split("\n")
    output_lines = []
    for line in lines:
        match = re.match(r"(\s*)<([^ ]*) '([^']*)'", line)
        if not match:
            continue
        indent, nodetype, name = match.groups()

        # only print top-level for short list
        if args.list:
            if not indent:
                output_lines.append(os.path.basename(name).replace(".py", ""))
        else:
            sys.stderr.write(indent + name)

    if args.list:
        colify(output_lines)


def test(parser, args, unknown_args):
    if args.pytest_help:
        # make the pytest.main help output more accurate
        with redirect_stdout():
            sys.argv[0] = "modulecmd test"
            pytest.main(["-h"])
        return

    pytest_root = modulecmd.paths.test_path

    # pytest.ini lives in the root of the modulecmd repository.
    with redirect_stdout():
        with working_dir(pytest_root):
            # --list and --long-list print the test output better.
            if args.list or args.long_list:
                do_list(args, unknown_args)
                return

            # Allow keyword search without -k if no options are specified
            if (
                args.tests
                and not unknown_args
                and not any(arg.startswith("-") for arg in args.tests)
            ):
                return pytest.main(["-k"] + args.tests)

            # Just run the pytest command
            return pytest.main(unknown_args + args.tests)
import sys

import modulecmd.system
import modulecmd.config
import modulecmd.environ

description = "Switch from using Modulecmd.py to TCL module (or vice-versa)"
section = "developer"
level = "long"


def setup_parser(subparser):
    pass


def switch(parser, args):  # pragma: no cover
    s = modulecmd.shell.switch()
    if modulecmd.config.get("dryrun"):
        sys.stderr.write(s)
    else:
        modulecmd.system.purge(load_after_purge=False)
        modulecmd.system.dump()
        sys.stdout.write(s)
import sys
import modulecmd.system

description = (
    "Display module whatis string.  The whatis string is a short informational\n"
    "message a module can provide.  If not defined by the module, a default is \n"
    "displayed."
)
section = "info"
level = "short"


def setup_parser(subparser):
    subparser.add_argument(
        "names", nargs="+", help="Module[s] to display whatis string"
    )


def whatis(parser, args):
    for name in args.names:
        s = modulecmd.system.whatis(name)
        sys.stderr.write(s + "\n")
import modulecmd.system

description = (
    "Print contents of a module or collection to the console output one\n"
    "page at a time.  Allows movement through files similar to shell's `less`\n"
    "program."
)
level = "short"
section = "info"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument("name", help="Name of module, collection, or config file")


def more(parser, args):
    modulecmd.system.more(args.name)
from modulecmd.command.common.parse_module_options import parse_module_options
import modulecmd.system

description = "Unload and reload all loaded modules"
level = "short"
section = "basic"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    pass


def refresh(parser, args):
    modulecmd.system.refresh()
    modulecmd.system.dump()
import sys
import modulecmd.system
import modulecmd.collection

description = "Manipulate collections of modules"
level = "short"
section = "collections"


_subcommands = {}


def add_avail_command(parser):
    def avail(args):
        s = modulecmd.collection.avail(terse=args.terse, regex=args.regex)
        sys.stderr.write(s)

    p = parser.add_parser("avail", help="List available (saved) collections")
    p.add_argument(
        "regex",
        nargs="?",
        metavar="regex",
        help='Highlight available modules matching "regex"',
    )
    p.add_argument(
        "-t",
        "--terse",
        action="store_true",
        default=False,
        help="Display output in terse format [default: %(default)s]",
    )
    _subcommands["avail"] = avail


def add_save_command(parser):
    def save(args):
        return modulecmd.system.save_collection(args.name)

    p = parser.add_parser("save", help="Save the current environment")
    p.add_argument(
        "name",
        nargs="?",
        default=modulecmd.names.default_user_collection,
        help="Name of collection to save",
    )
    _subcommands["save"] = save


def add_add_to_loaded_collection_command(parser):
    def add_to_loaded_collection(args):
        return modulecmd.system.add_to_loaded_collection(args.name)

    p = parser.add_parser("add", help="Add module to currently loaded collection")
    p.add_argument(
        "name",
        default=modulecmd.names.default_user_collection,
        help="Name of module to add to currently loaded collection",
    )
    _subcommands["add"] = add_to_loaded_collection


def add_pop_from_loaded_collection_command(parser):
    def pop_from_loaded_collection(args):
        return modulecmd.system.pop_from_loaded_collection(args.name)

    p = parser.add_parser("pop", help="Pop module from currently loaded collection")
    p.add_argument(
        "name",
        default=modulecmd.names.default_user_collection,
        help="Name of module to pop from currently loaded collection",
    )
    _subcommands["pop"] = pop_from_loaded_collection


def add_show_command(parser):
    def show(args):
        return modulecmd.system.show_collection(args.name)

    p = parser.add_parser(
        "show", help="Show actions that would be taken by restoring the collection"
    )
    p.add_argument(
        "name",
        nargs="?",
        default=modulecmd.names.default_user_collection,
        help="Name of collection to show",
    )
    _subcommands["show"] = show


def add_remove_command(parser):
    def remove(args):
        return modulecmd.system.remove_collection(args.name)

    p = parser.add_parser("remove", help="Remove collection")
    p.add_argument("name", help="Name of collection to remove")
    _subcommands["remove"] = remove


def add_restore_command(parser):
    def restore(args):
        modulecmd.system.restore_collectionstore(args.name)
        modulecmd.system.dump()

    p = parser.add_parser("restore", help="Restore collection")
    p.add_argument(
        "name",
        nargs="?",
        default=modulecmd.names.default_user_collection,
        help="Name of collection to restore",
    )
    _subcommands["restore"] = restore


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    sp = subparser.add_subparsers(metavar="SUBCOMMAND", dest="subcommand")
    add_avail_command(sp)
    add_save_command(sp)
    add_show_command(sp)
    add_remove_command(sp)
    add_restore_command(sp)
    add_add_to_loaded_collection_command(sp)
    add_pop_from_loaded_collection_command(sp)


def collection(parser, args):
    _subcommands[args.subcommand](args)
import modulecmd.system

description = "Show path to module file"
level = "short"
section = "info"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument("names", nargs="+", help="Name of module")


def find(parser, args):
    modulecmd.system.find(args.names)
import sys
import modulecmd.system


description = "Displays available modules"
level = "short"
section = "basic"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument(
        "regex",
        nargs="?",
        metavar="regex",
        help='Highlight available modules matching "regex"',
    )
    subparser.add_argument(
        "-t",
        "--terse",
        default=False,
        action="store_true",
        help="Display output in terse format [default: %(default)s]",
    )
    subparser.add_argument(
        "-a",
        default=False,
        action="store_true",
        help="Include available clones and collections [default: %(default)s]",
    )


def avail(parser, args):
    avail = modulecmd.system.avail(terse=args.terse, regex=args.regex, show_all=args.a)
    sys.stderr.write(avail)
import os

import modulecmd.system
import modulecmd.names
import modulecmd.collection
from modulecmd.util.lang import split

description = "Initialize modules (should only be called by the startup script)."
level = "long"
section = "init"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument(
        "-p", "--modulepath", default=os.getenv("MODULEPATH"), help="Initial MODULEPATH"
    )


def init(parser, args):

    modulepath = split(args.modulepath, os.pathsep)
    modulecmd.system.init(modulepath)
    modulecmd.system.dump()
import os
import argparse

import modulecmd.system
from modulecmd.command.common import parse_module_options

description = "Load modules into environment"
level = "short"
section = "basic"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument(
        "-i",
        "--insert-at",
        type=int,
        default=None,
        help="Load the module as the `i`th module.",
    )
    subparser.add_argument(
        "args",
        nargs=argparse.REMAINDER,
        help=(
            "Modules and options to load. Additional options can be sent \n"
            "directly to the module using the syntax, `+option[=value]`. \n"
            "See the module options help for more details."
        ),
    )


def load(parser, args):
    argv = parse_module_options(args.args)
    for (i, spec) in enumerate(argv):
        insert_at = args.insert_at if i == 0 else None
        name = (
            spec["name"]
            if spec["version"] is None
            else os.path.sep.join([spec["name"], spec["version"]])
        )
        modulecmd.system.load(name, opts=spec["options"], insert_at=insert_at)
    modulecmd.system.dump()
import sys
import modulecmd.system
import modulecmd.command
import modulecmd.modulepath
from modulecmd.util.tty import redirect_stdout

description = "get help on modulecmd and its commands"
section = "help"
level = "short"


def setup_parser(subparser):
    help_cmd_group = subparser.add_mutually_exclusive_group()
    help_cmd_group.add_argument(
        "help_command", nargs="?", default=None, help="command or module to get help on"
    )

    help_all_group = subparser.add_mutually_exclusive_group()
    help_all_group.add_argument(
        "-a",
        "--all",
        action="store_const",
        const="long",
        default="short",
        help="print all available commands",
    )


def help(parser, args):

    if args.help_command:
        if args.help_command in modulecmd.command.all_commands():  # pragma: no cover
            parser.add_command(args.help_command)
            with redirect_stdout():
                parser.parse_args([args.help_command, "-h"])
        else:
            with redirect_stdout():
                s = modulecmd.system.help(args.help_command)
                sys.stderr.write(s)

    else:
        with redirect_stdout():
            sys.stderr.write(parser.format_help(level=args.all))
import modulecmd.system

description = "Provides information on a particular loaded module"
level = "short"
section = "basic"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument(
        "names", nargs="+", help="Name[s] of loaded modules to get information for"
    )


def info(parser, args):
    modulecmd.system.info(args.names)
import os
import sys
import modulecmd.modulepath

description = "Show MODULEPATH"
level = "short"
section = "modulepath"


def setup_parser(subparser):
    pass


def path(parser, args):
    home = os.path.expanduser("~")
    paths = []
    for path in modulecmd.modulepath.path():
        paths.append(path.replace(home, "~"))
    s = "\n".join(
        "{0}) {1}".format(i, dirname) for i, dirname in enumerate(paths, start=1)
    )
    sys.stderr.write(s + "\n")
import modulecmd.system


description = "Remove (unuse) directory[s] from MODULEPATH"
level = "short"
section = "modulepath"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument("path", help="Path[s] to unuse.")


def unuse(parser, args):
    modulecmd.system.unuse(args.path)
    modulecmd.system.dump()
import modulecmd.system

description = "Restore saved modules or, optionally, a clone"
level = "short"
section = "collections"


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    subparser.add_argument(
        "name",
        nargs="?",
        default=modulecmd.names.default_user_collection,
        help="Name of collection or clone to restore",
    )


def restore(parser, args):
    modulecmd.system.restore_collection(args.name)
    modulecmd.system.dump()
from __future__ import print_function

import os
import re
import sys
import argparse

import llnl.util.tty as tty
from llnl.util.tty.colify import colify
from llnl.util.argparsewriter import ArgparseWriter, ArgparseRstWriter

import modulecmd.main
from modulecmd.main import section_descriptions


description = "list available Modulecmd.py commands"
section = "developer"
level = "long"


#: list of command formatters
formatters = {}


def formatter(func):
    """Decorator used to register formatters"""
    formatters[func.__name__] = func
    return func


def setup_parser(subparser):
    subparser.add_argument(
        "--format",
        default="names",
        choices=formatters,
        help="format to be used to print the output (default: names)",
    )
    subparser.add_argument(
        "--header",
        metavar="FILE",
        default=None,
        action="store",
        help="prepend contents of FILE to the output (useful for rst format)",
    )
    subparser.add_argument(
        "--update",
        metavar="FILE",
        default=None,
        action="store",
        help="write output to the specified file, if any command is newer",
    )
    subparser.add_argument(
        "rst_files",
        nargs=argparse.REMAINDER,
        help="list of rst files to search for `_cmd-module-<cmd>` cross-refs",
    )


class PymodArgparseRstWriter(ArgparseRstWriter):
    """RST writer tailored for Modulecmd.py documentation."""

    def __init__(self, documented_commands, out=sys.stderr):
        super(PymodArgparseRstWriter, self).__init__(out)
        self.documented = documented_commands if documented_commands else []

    def usage(self, *args):
        super(PymodArgparseRstWriter, self).usage(*args)
        command = re.sub(" ", "-", self.parser.prog)
        if command in self.documented:  # pragma: no cover
            self.line()
            self.line(":ref:`More documentation <cmd-%s>`" % command)


class SubcommandWriter(ArgparseWriter):
    def begin_command(self, prog):
        self.out.write("    " * self.level + prog)
        self.out.write("\n")


@formatter
def subcommands(args, out):
    parser = modulecmd.main.make_argument_parser()
    modulecmd.main.add_all_commands(parser)
    SubcommandWriter(out).write(parser)


def rst_index(out=sys.stderr):
    out.write("\n")

    index = modulecmd.main.index_commands()
    sections = index["long"]

    dmax = max(len(section_descriptions.get(s, s)) for s in sections) + 2
    cmax = max(len(c) for _, c in sections.items()) + 60

    row = "%s  %s\n" % ("=" * dmax, "=" * cmax)
    line = "%%-%ds  %%s\n" % dmax

    out.write(row)
    out.write(line % (" Category ", " Commands "))
    out.write(row)
    for section, commands in sorted(sections.items()):
        description = section_descriptions.get(section, section)

        for i, command in enumerate(sorted(commands)):
            description = description.capitalize() if i == 0 else ""
            ref = ":ref:`%s <modulecmd-%s>`" % (command, command)
            comma = "," if i != len(commands) - 1 else ""
            bar = "| " if i % 8 == 0 else "  "
            out.write(line % (description, bar + ref + comma))
    out.write(row)


@formatter
def rst(args, out):
    # create a parser with all commands
    parser = modulecmd.main.make_argument_parser()
    modulecmd.main.add_all_commands(parser)

    # extract cross-refs of the form `_cmd-modulecmd-<cmd>:` from rst files
    documented_commands = set()
    for filename in args.rst_files:  # pragma: no cover
        with open(filename) as f:
            for line in f:
                match = re.match(r"\.\. _cmd-(modulecmd-.*):", line)
                if match:
                    documented_commands.add(match.group(1).strip())

    # print an index to each command
    rst_index(out)
    out.write("\n")

    # print sections for each command and subcommand
    PymodArgparseRstWriter(documented_commands, out).write(parser, root=1)


@formatter
def names(args, out):
    colify(modulecmd.command.all_commands(), output=out)


def prepend_header(args, out):  # pragma: no cover
    if not args.header:
        return

    with open(args.header) as header:
        out.write(header.read())


def commands(parser, args):

    # Print to stderr
    formatter = formatters[args.format]

    # check header first so we don't open out files unnecessarily
    if args.header and not os.path.exists(args.header):  # pragma: no cover
        tty.die("No such file: '%s'" % args.header)

    # if we're updating an existing file, only write output if a command
    # is newer than the file.
    if args.update:  # pragma: no cover
        if os.path.exists(args.update):
            files = [
                modulecmd.command.get_module(command).__file__.rstrip("c")  # pyc -> py
                for command in modulecmd.command.all_commands()
            ]
            last_update = os.path.getmtime(args.update)
            if not any(os.path.getmtime(f) > last_update for f in files):
                tty.msg("File is up to date: %s" % args.update)
                return

        tty.msg("Updating file: %s" % args.update)
        with open(args.update, "w") as f:
            prepend_header(args, f)
            formatter(args, f)

    else:
        prepend_header(args, sys.stderr)
        formatter(args, sys.stderr)
import sys
import modulecmd.system
import modulecmd.clone

description = "Manipulate cloned environments"
level = "short"
section = "clones"


_subcommands = {}


def add_avail_command(parser):
    def avail(args):
        s = modulecmd.clone.avail(args.terse)
        sys.stderr.write(s)

    p = parser.add_parser("avail", help="List available (saved) clones")
    p.add_argument("-t", "--terse", action="store_true", help="Terse output")
    _subcommands["avail"] = avail


def add_save_command(parser):
    def save(args):
        return modulecmd.system.save_clone(args.name)

    p = parser.add_parser("save", help="Save the current environment")
    p.add_argument("name", help="Name of clone")
    _subcommands["save"] = save


def add_remove_command(parser):
    def remove(args):
        return modulecmd.system.remove_clone(args.name)

    p = parser.add_parser("remove", help="Remove clone")
    p.add_argument("name", help="Name of clone to remove")
    _subcommands["remove"] = remove


def add_restore_command(parser):
    def restore(args):
        modulecmd.system.restore_clone(args.name)
        modulecmd.system.dump()

    p = parser.add_parser("restore", help="Restore cloned environment")
    p.add_argument("name", help="Name of clone to restore")
    _subcommands["restore"] = restore


def setup_parser(subparser):
    """Parser is only constructed so that this prints a nice help
       message with -h. """
    sp = subparser.add_subparsers(metavar="SUBCOMMAND", dest="subcommand")
    add_avail_command(sp)
    add_save_command(sp)
    add_remove_command(sp)
    add_restore_command(sp)


def clone(parser, args):
    _subcommands[args.subcommand](args)
import modulecmd.system
import modulecmd.modes
from modulecmd.error import ModuleNotFoundError

category = "module"


def load_first(module, mode, *names):
    """Load the first of modules in `names`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        names (tuple of str): Names of modules to load

    Returns:
        loaded (Module): The loaded module

    Notes:
    - In load mode, loads the first available module in `names` and returns it. In \
            unload mode, the first loaded module in `names` is unloaded.

    - If no available modules are found in `names`, an error occurs

    - If the last of `names` is None, no error is thrown if no available \
            modules are found in `names`

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        load_first('spam', 'eggs')

    On loading module ``baz``, the first available module of ``spam`` or ``eggs`` is loaded.

    .. code-block:: console

        $ module ls
        No loaded modules

        $ module load baz
        $ module ls
        Currently loaded modules
            1) eggs  2) baz

    The module ``eggs`` was loaded because ``spam`` was not available.

    """
    modulecmd.modes.assert_known_mode(mode)
    for name in names:
        if name is None:
            continue
        try:
            if mode == modulecmd.modes.unload:
                # We are in unload mode and the module was requested to be
                # loaded. So, we reverse the action and unload it
                return modulecmd.system.unload(name, caller="load_first")
            else:
                return modulecmd.system.load(name, caller="load_first")
        except ModuleNotFoundError:
            continue
    if names and name is None:
        return
    raise ModuleNotFoundError(",".join(names))
import modulecmd.system
import modulecmd.modes

category = "modulepath"


def use(module, mode, dirname, append=False):
    """Add the directory `dirname` to ``MODULEPATH``

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        dirname (str): Name of the directory to add to ``MODULEPATH``

    Keyword arguments:
        append (bool): Append `dirname` to ``MODULEPATH``, otherwise `dirname` \
                is prepended.  The default is ``False``.

    Notes:
    In load mode, adds `dirname` to the ``MODULEPATH``.  In unload mode, remove
    `dirname` from the ``MODULEPATH`` (if it is on ``MODULEPATH``).

    This function potentially has side effects on the environment.  When
    a directory is ``use``\ d, modules in its path may have higher precedence than
    modules on the previous ``MODULEPATH``.  Thus, defaults could change and loaded
    modules could be swapped for newer modules with higher precedence.

    """
    modulecmd.modes.assert_known_mode(mode)
    if mode == modulecmd.modes.unload:
        modulecmd.system.unuse(dirname)
    else:
        modulecmd.system.use(dirname, append=append)
        module.unlocks_path(dirname)
import os
import modulecmd.modes
import modulecmd.names
import modulecmd.environ
import modulecmd.callback

category = "path"


def prepend_path(module, mode, name, *values, **kwds):
    """Prepend `values` to path-like variable `name`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of path-like variable
        values (tuple of str): The values to prepend to path-like variable `name`

    Keyword arguments:
        sep (str): defines the separator between values in path-like variable \
            `name`  (default is os.pathsep)

    Notes:
    - In *unload* mode, `values` are removed from path-like variable `name`, \
      otherwise, they are prepended.

    - If ``name==MODULEPATH``, this function calls ``use(value)`` \
      for each `value` in `values`.

    - A path-like variable stores a list as a ``sep`` separated string.  eg, the \
      PATH environment variable is a ``sep`` separated list of directories:

      .. code-block:: console

          $ echo ${PATH}
          dirname1:dirname2:...

    Here, ":" is the separator ``sep``.

    Examples:
    Consider the module ``baz`` that prepends `baz` to the path-like environment variable `BAZ`

    .. code-block:: python

        prepend_path('BAZ', 'baz')

    The environment variable ``BAZ`` is currently

    .. code-block:: console

        $ echo ${BAZ}
        spam

    On loading the module ``baz``, the environment variable ``BAZ`` is updated:

    .. code-block:: console

        $ module load baz
        $ echo ${BAZ}
        baz:spam

    """
    modulecmd.modes.assert_known_mode(mode)
    if name == modulecmd.names.modulepath:
        for value in values:
            modulecmd.callback.use.use(module, mode, value)
        return
    sep = kwds.get("sep", os.pathsep)
    if mode == modulecmd.modes.unload:
        for value in values:
            modulecmd.environ.remove_path(name, value, sep)
    else:
        for value in values:
            modulecmd.environ.prepend_path(name, value, sep)
import modulecmd.system
import modulecmd.modes

category = "utility"


def raw(module, mode, *commands, **kwargs):
    """Runs raw shell commands

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        commands (tuple of str): commands to run

    Keyword arguments:
        when (bool): Logical describing when to run `commands`.  If `None` \
                or `True`, the `commands` are run.

    Notes:
    - **Warning:** This function runs the shell commands unconditionally.  Environment \
            modifications made by the script are not tracked by Modulecmd.py.

    - commands are only run if ``mode()=='load'``

    Examples:
    Consider the module ``baz``:

    .. code-block:: python

        raw("alias bar='spam'", when=mode()=='load')

    The command ``<command>`` will be run when the module is loaded.

    """
    modulecmd.modes.assert_known_mode(mode)
    when = kwargs.get("when", None)
    if when is not None and not when:
        return
    modulecmd.system.raw(*commands)
import modulecmd.system
import modulecmd.modes

category = "module"


def swap(module, mode, cur, new, **kwargs):
    """Swap module `cur` for module `new`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        cur (str): The name of the module to unload
        new (str): The name of the module to load in place of `cur`

    Returns:
        loaded (Module): `cur`\ 's module object

    Notes:
    - In load mode, perform an unload of `cur` followed by a load of `new`.  However, \
            when unloading `cur`, all modules loaded after `cur` are also unloaded in \
            reverse order.  After loading `new`, the unloaded modules are reloaded in \
            the order they were originally loaded.

    - If MODULEPATH changes as a result of the swap, it is possible that some of these \
            modules will be swapped themselves, or not reloaded at all.

    - In unload mode, the swap is not performed.

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        swap('spam', 'eggs')

    On loading ``baz``, the module ``spam`` is swapped for ``eggs`` (if it is already loaded)

    .. code-block:: console

        $ module ls
        Currently loaded modules
            1) spam

        $ module load baz
        Currently loaded modules
            1) eggs  2) baz
    """
    modulecmd.modes.assert_known_mode(mode)
    if mode != modulecmd.modes.unload:
        # We don't swap modules in unload mode
        return modulecmd.system.swap(cur, new, caller="modulefile")
import modulecmd.modes
import modulecmd.environ

category = "environment"


def unsetenv(module, mode, name, *args):
    """Unset value of environment variable `name`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of the environment variable

    Notes:
    In unload mode, nothing is done

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        unsetenv("BAZ")

    .. code-block:: console

        $ echo ${BAZ}
        baz

    On loading, the environment variable ``BAZ`` is unset

    .. code-block:: console

        $ module load baz
        $ echo ${BAZ}

    """
    modulecmd.modes.assert_known_mode(mode)
    if mode != modulecmd.modes.unload:
        return modulecmd.environ.unset(name)
import os
import subprocess
import modulecmd.modes
import modulecmd.environ
import llnl.util.tty as tty
from modulecmd.util.lang import split
from spack.util.executable import Executable

category = "utility"


def execute(module, mode, command, when=None):
    """Executes the command `command` in a subprocess

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        command (str): The command to execute in a shell subprocess

    Keyword arguments:
        when (bool): Logical describing when to execute `command`.  If `None` \
                or `True`, `command` is executed.

    Examples:
    Consider the module ``baz``:

    .. code-block:: python

        execute(<command>, when=mode()=='load')

    The command ``<command>`` will be executed in a subprocess when the module is loaded.

    """
    modulecmd.modes.assert_known_mode(mode)
    if when is not None and not when:
        return

    xc = split(command, " ", 1)
    exe = Executable(xc[0])
    with open(os.devnull, "a") as fh:
        kwargs = {
            "env": modulecmd.environ.filtered(),
            "output": fh,
            "error": subprocess.sys.stdout,
        }
        try:
            exe(*xc[1:], **kwargs)
        except:  # noqa: E722;  pragma: no cover
            tty.warn("Command {0!r} failed".format(command))
    return
import modulecmd.error

category = "utility"


def stop(module, mode):
    """Stop loading this module at this point

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution

    Notes:
    All commands up to the call to `stop` are executed.

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        # Actions to perform
        ...
        if condition:
            stop()

        # Actions not performed if condition is met

    """
    raise modulecmd.error.StopLoadingModuleError


stop.eval_on_show = True
import modulecmd.system
import modulecmd.modes
from modulecmd.error import ModuleNotFoundError

category = "module"


def unload(module, mode, name):
    """Unload the module `name`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of the module to unload

    Notes:
    - In load mode, decrements the reference count of the module found by `name`. \
            If the reference count drops to 0, the module is unloaded.

    - If the module is not found, or is not loaded, nothing is done.

    - In unload mode, nothing is done.

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        unload('spam')

    On loading ``baz``, the module ``spam`` is unloaded (if it is already loaded)

    .. code-block:: console

        $ module ls
        Currently loaded modules
            1) spam

        $ module load baz
        Currently loaded modules
            1) baz

    """
    modulecmd.modes.assert_known_mode(mode)
    if mode == modulecmd.modes.unload:
        # We are in unload mode and the module was requested to be
        # unloaded. But, we don't know if it was previously loaded. So we
        # skip
        return
    else:
        try:
            modulecmd.system.unload(name, caller="modulefile")
        except ModuleNotFoundError:
            return None
import os
import modulecmd.modes
import modulecmd.names
import modulecmd.environ
import modulecmd.callback

category = "path"


def append_path(module, mode, name, *values, **kwargs):
    """Append `values` to path-like variable `name`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of path-like variable
        values (tuple of str): The values to append to path-like variable `name`

    Keyword arguments:
        sep (str): defines the separator between values in path-like variable \
            `name`  (default is os.pathsep)

    Notes:
    - In *unload* mode, `values` are removed from path-like variable `name`, \
      otherwise, they are appended.

    - If ``name==MODULEPATH``, this function calls ``use(value, append=True)`` \
      for each `value` in `values`.

    - A path-like variable stores a list as a ``sep`` separated string.  eg, the \
      PATH environment variable is a ``sep`` separated list of directories:

      .. code-block:: console

          $ echo ${PATH}
          dirname1:dirname2:...

    Here, ":" is the separator ``sep``.

    Examples:
    Consider the module ``baz`` that appends `baz` to the path-like environment variable `BAZ`

    .. code-block:: python

        append_path('BAZ', 'baz')

    The environment variable ``BAZ`` is currently

    .. code-block:: console

        $ echo ${BAZ}
        spam

    On loading the module ``baz``, the environment variable ``BAZ`` is updated:

    .. code-block:: console

        $ module load baz
        $ echo ${BAZ}
        spam:baz

    """
    modulecmd.modes.assert_known_mode(mode)
    if name == modulecmd.names.modulepath:
        for value in values:
            modulecmd.callback.use.use(module, mode, value, append=True)
        return
    sep = kwargs.get("sep", os.pathsep)
    if mode == modulecmd.modes.unload:
        for value in values:
            modulecmd.environ.remove_path(name, value, sep)
    else:
        for value in values:
            modulecmd.environ.append_path(name, value, sep)
"""Defines callback functions between modules and modulecmd.

Modulecmd.py executes modulefiles in a sandbox with several functions made
available that allow the modulefile to interact with the user's environment.
Each of these functions is defined in this `modulecmd.callback` package.  The module
`system.execmodule` reads in each callback function and sets up a sandbox in
which modulefiles are executed.  Adding a module to this directory, with
a function having the same name as the module, automatically makes that function
available to modulefiles.

Each function is wrapped by the function `callback`, defined below.  It is this
wrapped function that is sent to user's modulefiles.  Each callback function
must have for the first two arguments: module, mode.  The callback wrapper
strips these arguments so that they are *invisible* to user's modulefiles.  Eg,
consider the function `baz` that takes arguments `spam` and `eggs`.  Its
signature is

```
def baz(module, mode, spam, eggs):
    ...
```

But, the wrapped function seen by modulefiles is

```
baz(spam, eggs)
```

This allows the function `baz` to change its implementation depending on the
mode or module.  For instance, when a module is loaded, the function
`append_path(name, path)` appends `path` to the environment variable `name`.
But, when a module is unloaded, `append_path` *removes* `path` from the
environment variable `name`.

"""

from __future__ import print_function

import os
import re
import sys
from six import StringIO

import modulecmd.modes
import modulecmd.paths
import modulecmd.system

from llnl.util.lang import attr_setdefault
import llnl.util.tty as tty


# Patterns to ignore in the callbacks directory when looking for callbacks.
ignore_files = r"^\.|^__init__.py$|^#|flycheck_"

CATEGORY = "category"


#: global, cached list of all callbacks -- access through all_callbacks()
_all_callbacks = None


def log_callback(func_name, *args, **kwargs):
    signature = StringIO()
    signature.write("{0}(".format(func_name))
    if args:
        signature.write(", ".join("{0!r}".format(_) for _ in args))
    if kwargs:
        if args:
            signature.write(", ")
        signature.write(", ".join("{0}={1!r}".format(*_) for _ in kwargs.items()))
    signature.write(")\n")
    modulecmd.system.trace(signature.getvalue())


def all_callbacks():
    """Get a sorted list of all modulecmd callbacks.

    This will list the lib/modulecmd/modulecmd/callback directory and find the
    callbacks there to construct the list.  It does not actually import
    the python files -- just gets the names.
    """
    global _all_callbacks
    if _all_callbacks is None:
        _all_callbacks = []
        callback_paths = [modulecmd.paths.callback_path]  # Built-in callbacks
        for path in callback_paths:
            for file in os.listdir(path):
                if file.endswith(".py") and not re.search(ignore_files, file):
                    callback = re.sub(r".py$", "", file)
                    _all_callbacks.append(callback)

        _all_callbacks.sort()

    return _all_callbacks


def callback(func_name, module, mode, when=None, **kwds):
    """Create a callback function by wrapping `func`

    Parameters
    ----------
    func_name : str
        The name of the function object to wrap
    module : Module
        The module being executed
    mode : Mode
        The mode of execution
    when : bool
        Conditional defining when to evaluate the callback.  If None (unset) or
        True, the function `func` is wrapped.  Otherwise, an empty lambda is
        wrapped.
    kwds : dict
        Extra keyword arguments to be sent to `func`

    Notes
    -----
    This function is intended to be used by system.execmodule to wrap
    functions to be sent to modules being executed.  The functions allow modules
    to interact with and modify modulecmd.environ, which in turn modifies the
    user's shell environment.

    The `module` and `mode` arguments are the first two arguments to any
    function wrapped.  `module` is the Module object of the module being
    executed and `mode` is the execution mode (i.e., 'load', 'unload', etc.)

    """
    func = get_callback(func_name)
    return callback_impl(func, module, mode, when=when, **kwds)


def callback_impl(func, module, mode, when=None, **kwds):
    if when is None:
        when = (
            mode != modulecmd.modes.load_partial and mode not in modulecmd.modes.informational
        )
    if not when:
        func = lambda *args, **kwargs: None

    def wrapper(*args, **kwargs):
        if mode == modulecmd.modes.show:
            log_callback(func.__name__, *args, **kwargs)
            if not getattr(func, "eval_on_show", False):
                return
        kwargs.update(kwds)
        return func(module, mode, *args, **kwargs)

    return wrapper


def get_module(cb_name):
    """Imports the module for a particular callback name and returns it.

    Parameters
    ----------
    cb_name : str
        name of the callback for which to get a module (contains ``-``, not ``_``).
    """
    # Import the callback from the built-in directory
    module_name = "{0}.{1}".format(__name__, cb_name)
    module = __import__(module_name, fromlist=[cb_name, CATEGORY], level=0)

    attr_setdefault(module, CATEGORY, "")

    if not hasattr(module, cb_name):  # pragma: no cover
        tty.die(
            "callback module {0} ({1}) must define function {2!r}.".format(
                module.__name__, module.__file__, cb_name
            )
        )

    return module


def get_callback(cb_name):
    """Imports the callback's function from a module and returns it.

    Parameters
    ----------
    cb_name : str
        name of the callback for which to get a module
    """
    return getattr(get_module(cb_name), cb_name)
import modulecmd.modes
import modulecmd.environ

category = "alias"


def set_alias(module, mode, name, value):
    """Define a shell alias

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of the alias
        value (str): Value of the alias

    Notes:
    In unload mode, undefines the alias.  Otherwise, defines the alias.

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        set_alias('baz', 'ls -l')

    On loading ``baz``, the alias is defined

    .. code-block:: console

        $ module load baz
        $ alias baz
        alias baz='ls -l'

    On unloading ``baz``, the alias is undefined

    .. code-block:: console

        $ module ls
        Currently loaded module
            1) baz

        $ module unload baz
        $ alias baz
        -bash: alias: baz: not found

    """
    modulecmd.modes.assert_known_mode(mode)
    if mode == modulecmd.modes.unload:
        modulecmd.environ.unset_alias(name)
    else:
        modulecmd.environ.set_alias(name, value)
import socket
import modulecmd.modes

category = "utility"


def get_hostname(module, mode):
    """Returns the hostname

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution

    Returns:
        hostname (str): string containing the hostname of the machine where the Python interpreter is currently executing

    """
    modulecmd.modes.assert_known_mode(mode)
    return socket.gethostname()


get_hostname.eval_on_show = True
import modulecmd.system
import modulecmd.modes

category = "interaction"


def prereq(module, mode, *names):
    """Defines a prerequisite (module that must be loaded) for this module

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        names (tuple of str): Names of prerequisite modules

    Notes:
    In load mode, asserts that every `name` in `names` is loaded.  Otherwise, nothing is done.

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        prereq('spam', 'eggs')

    If any ``spam`` or ``eggs`` is not loaded, an error occurs:

    .. code-block:: console

        $ module ls
        Currently loaded module
            1) spam

        $ module load baz
        ==> Error: Prerequisite 'eggs' must first be loaded

    """
    # FIXME: This function should execute mc.prereq in any mode other than
    # unload.  In whatis, help, show, etc. modes, it should register the prereqs
    # but not enforce them.
    modulecmd.modes.assert_known_mode(mode)
    if mode == modulecmd.modes.load:
        modulecmd.system.prereq(*names)
import modulecmd.system
import modulecmd.modes

category = "interaction"


def conflict(module, mode, *names, **kwargs):
    """Defines conflicts (modules that conflict with `module`)

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        names (tuple of str): Names of conflicting modules

    Notes:
    In load mode, asserts that none of `names` is loaded.   Otherwise, nothing
    is done.

    """
    # FIXME: This function should execute mc.conflict in any mode other than
    # unload.  In whatis, help, show, etc. modes, it should register the
    # conflicts but not enforce them.

    modulecmd.modes.assert_known_mode(mode)
    if mode == modulecmd.modes.load:
        modulecmd.system.conflict(module, *names)
import modulecmd.modes

category = "info"


def whatis(module, mode, *args, **kwargs):
    """Sets the "whatis" informational string for `module`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        args (tuple of str): Information about the module

    Notes:
    - This function sets the information string displayed by

    .. code-block:: console

        $ module whatis <name>

    - Keyword arguments are interpreted as ``{title: description}``

    Examples:
    Consider the module ``baz``:

    .. code-block:: python

        whatis("A description about the module",
               a_title="A section in the whatis")

    .. code-block:: console

        $ module whatis baz
        A description about the module

        A Title
        A section in the whatis

    """
    modulecmd.modes.assert_known_mode(mode)
    return module.set_whatis(*args, **kwargs)
import modulecmd.modes

category = "utility"


def mode(module, mode):
    """Returns the current mode (load, unload, show, etc)

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution

    Returns:
        modestr (str): The mode of execution

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        # Actions to perform
        ...
        if mode() == 'load':
            # do something

    """
    return modulecmd.modes.as_string(mode)


mode.eval_on_show = True
from modulecmd.util.lang import check_output as _check_output

category = "utility"


def check_output(module, mode, command):
    """Run command with arguments and return its output as a string.

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        command (str): The command to run

    Returns:
        output (str): The output of `command`

    Notes:
    This is a wrapper to `modulecmd.util.check_output`.  Where
    `subprocess.check_output` exists, it is called.  Otherwise, an implementation of
    `subprocess.check_output` is provided.

    """
    return _check_output(command)
import modulecmd.error
import llnl.util.tty as tty

category = "utility"


def _break(module, mode):
    """Implementation of TCL module "break" command

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution

    Notes:
    If a TCL module issues the "break" command, all modifications done to the \
    environment up to that point are reversed, as if the module had never been \
    executed.

    """
    tty.warn("Evaluation of {0} aborted".format(module.fullname))
    raise modulecmd.error.TclModuleBreakError
import modulecmd.system
import modulecmd.modes
import modulecmd.environ

category = "utility"


def getenv(module, mode, key, default=None):
    """Return the value of the environment variable `key` if it exists, or `default` if it doesn't.

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        key (str): The environment variable

    Keyword Arguments:
        default (str): The default value

    Returns:
        value (str): The value of the environment variable `key` if it exists, or `default` if it doesn't.

    Notes:
    - Retrieves values of environment variables from current active
      environment. The difference between `getenv` and `os.getenv` is that
      `os.getenv` is not updated to reflect environment variables that may be
      have set in this, or other modules, load/unloaded in this session.

    """
    modulecmd.modes.assert_known_mode(mode)
    return modulecmd.environ.get(key, default=default)


getenv.eval_on_show = True
import modulecmd.error

category = "utility"


def _continue(module, mode):
    """Implementation of TCL module "continue" command

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution

    Notes:
    If a TCL module issues the "continue" command, evaluation of the module \
    stops, but the changes made up to that point are maintained.

    """
    raise modulecmd.error.StopLoadingModuleError
import modulecmd.modes
import modulecmd.environ

category = "environment"


def setenv(module, mode, name, value):
    """Set value of environment variable `name`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of the environment variable
        value (str): Value to set for environment variable `name`

    Notes:
    In unload mode, the environment variable is unset.  Otherwise, it is set.

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        setenv('BAZ', 'baz')

    On loading ``baz``, the environment variable is set

    .. code-block:: console

        $ module load baz
        $ echo ${BAZ}
        baz

    On unloading ``baz``, the environment variable is unset

    .. code-block:: console

        $ module ls
        Currently loaded module
            1) baz

        $ module unload baz
        $ echo ${BAZ}

    """
    modulecmd.modes.assert_known_mode(mode)
    if mode == modulecmd.modes.unload:
        return modulecmd.environ.unset(name)
    else:
        return modulecmd.environ.set(name, value)
import os
import modulecmd.modes
import modulecmd.names
import modulecmd.environ
import modulecmd.callback

category = "path"


def remove_path(module, mode, name, *values, **kwds):
    """Removes `values` from the path-like variable `name`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of path-like variable
        values (tuple of str): The values to remove from the path-like variable `name`

    Keyword arguments:
        sep (str): defines the separator between values in path-like variable \
            `name`  (default is os.pathsep)

    Notes:
    - In *unload* mode, nothing is done.  Otherwise, `values` are removed from \
      path-like variable `name`.

    - If ``name==MODULEPATH``, this function calls ``unuse(value)`` \
      for each `value` in `values`.

    - A path-like variable stores a list as a ``sep`` separated string.  eg, the \
      PATH environment variable is a ``sep`` separated list of directories:

      .. code-block:: console

          $ echo ${PATH}
          dirname1:dirname2:...

    Here, ":" is the separator ``sep``.

    Examples:
    Consider the module ``baz`` that removes `baz` from the path-like
    environment variable `BAZ`

    .. code-block:: python

        remove_path('BAZ', 'baz')

    The environment variable ``BAZ`` is currently

    .. code-block:: console

        $ echo ${BAZ}
        baz:spam

    On loading the module ``baz``, the environment variable ``BAZ`` is updated:

    .. code-block:: console

        $ module load baz
        $ echo ${BAZ}
        spam

    """
    modulecmd.modes.assert_known_mode(mode)
    if name == modulecmd.names.modulepath:
        for value in values:
            modulecmd.callback.unuse.unuse(module, mode, value)
        return
    sep = kwds.get("sep", os.pathsep)
    if mode != modulecmd.modes.unload:
        for value in values:
            modulecmd.environ.remove_path(name, value, sep)
import modulecmd.system
import modulecmd.modes

category = "family"


def family(module, mode, family_name):
    """Defines the "family" of the module

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        family_name (str): Name of the family

    Notes:
    - Only one module in a family can be loaded at a time.  For instance, GCC and \
      Intel compiler modules can define their family as "compiler".  This prevents \
      GCC and Intel compilers being loaded simultaneously.

    - This function potentially has side effects on the environment.  When \
      a module is loaded, if a module of the same family is already loaded, they \
      will be swapped.  Swapping has the potential to change the ``MODULEPATH`` and \
      state of loaded modules.

    Examples:
    Consider modules ``ucc`` and ``xcc`` that are both members of the ``compiler`` family.
    The module ``ucc/1.0`` is already loaded

    .. code-block:: console

        $ module ls
        Currently loaded modules
            1) ucc/1.0

    On loading ``xcc/1.0``, ``ucc/1.0`` is unloaded

    .. code-block:: console

        $ module load xcc/1.0

        The following modules in the same family have been updated with a version change:
          1) ucc/1.0 => xcc/1.0 (compiler)

    """
    modulecmd.modes.assert_known_mode(mode)
    modulecmd.system.family(module, mode, family_name)
import modulecmd.modes
import modulecmd.names
import modulecmd.environ

category = "family"


def get_family_info(module, mode, name, **kwargs):
    """Returns information about family `name`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): The name of the family to get information about

    Returns:
        family_name (str): The module name in family `name`
        version (str): The version of the module in family `name`

    Notes:
    If a module of family `name` is loaded, this function returns its name and
    version.  Otherwise, the name and version return as `None`

    Examples:
    The following module performs actions if the compiler ``ucc`` is loaded

    .. code-block:: python

        name, version = get_family_info('compiler')
        if name == 'ucc':
            # Do something specific if ucc is loaded

    """
    modulecmd.modes.assert_known_mode(mode)
    name_envar = modulecmd.names.family_name(name)
    version_envar = modulecmd.names.family_version(name)
    return modulecmd.environ.get(name_envar), modulecmd.environ.get(version_envar)
import modulecmd.modes
import modulecmd.environ

category = "alias"


def unset_alias(module, mode, name):
    """Undefine a shell alias

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of the shell alias

    Notes:
    In unload mode, nothing is done.  Otherwise, the alias given by `name` is undefined

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        unset_alias("baz")

    .. code-block:: console

        $ alias baz
        alias baz='echo "I am a baz!"'

    On loading, the alias ``baz`` is undefined

    .. code-block:: console

        $ module load baz
        $ alias baz
        -bash: alias: baz: not found

    """
    modulecmd.modes.assert_known_mode(mode)
    if mode != modulecmd.modes.unload:
        modulecmd.environ.unset_alias(name)
import modulecmd.modes
import modulecmd.environ

category = "alias"


def set_shell_function(module, mode, name, value):
    """Define a shell function

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of the function
        value (str): Value of the function

    Notes:
    In unload mode, undefines the shell function.  Otherwise, defines the shell function

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        set_shell_function('baz', 'ls -l $1')

    On loading ``baz``, the shell function is defined

    .. code-block:: console

        $ module load baz
        $ declare -f baz
        baz ()
        {
            ls -l $1
        }

    On unloading ``baz``, the shell function is undefined

    .. code-block:: console

        $ module ls
        Currently loaded module
            1) baz

        $ module unload baz
        $ declare -f baz

    """
    modulecmd.modes.assert_known_mode(mode)
    if mode == modulecmd.modes.unload:
        modulecmd.environ.unset_shell_function(name)
    else:
        modulecmd.environ.set_shell_function(name, value)
import modulecmd.modes
import modulecmd.modulepath

category = "info"


def is_loaded(module, mode, name):
    """Report whether the module `name` is loaded

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of the module to report

    Returns:
        is_loaded (bool): Whether the module given by `name` is loaded

    Examples:

    .. code-block:: python

        if is_loaded('baz'):
            # Do something if baz is loaded
            ...

    """
    modulecmd.modes.assert_known_mode(mode)
    other = modulecmd.modulepath.get(name)
    if other is None:
        return None
    return other.is_loaded
import modulecmd.system
import modulecmd.modes
from modulecmd.error import ModuleNotFoundError

category = "module"


def load(module, mode, name, **kwds):
    """Load the module `name`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of module to load

    Keyword arguments:
        opts (dict): Module options


    Notes:
    - In load mode, loads the module found by `name` if it is not already loaded. \
            If it is loaded, its internal reference count is incremented.

    - In unload mode, decrements the reference count of the module found by \
            `name`.  If the reference count gets to 0, the module is unloaded.

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        load('spam', opts={'x': True})

    On loading module ``baz``, the module ``spam``, if available, is loaded with options
    ``opts``.

    .. code-block:: console

        $ module ls
        No loaded modules

        $ module load baz
        $ module ls
        Currently loaded modules
            1) eggs x=True  2) baz

    """
    modulecmd.modes.assert_known_mode(mode)
    opts = kwds.get("opts", None)
    modulecmd.modes.assert_known_mode(mode)
    if mode == modulecmd.modes.unload:
        # We are in unload mode and the module was requested to be loaded.
        # So, we reverse the action and unload it
        try:
            modulecmd.system.unload(name, caller="modulefile")
        except ModuleNotFoundError:
            return
    else:
        modulecmd.system.load(name, opts=opts, caller="modulefile")
from modulecmd.util.lang import listdir as _listdir

category = "utility"


def listdir(module, mode, dirname, key=None):
    """List contents of directory `dirname`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        dirname (str): Path to directory

    Keyword arguments:
        key (callable): Filter for contents in `dirname`

    Returns:
        contents (list): Contents of `dirname`

    Notes:
    - This is a wrapper to ``modulecmd.util.listdir``
    - If ``key`` is given, it must be a callable object

    """
    return _listdir(dirname, key=key)
from modulecmd.util.lang import which as _which

category = "utility"


def which(module, mode, exename):
    """Return the path to an executable, if found on PATH

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        exename (str): The name of the executable

    Returns:
        which (str): The full path to the executable

    Notes:
    This is a wrapper to `contib.util.which`.

    """
    return _which(exename)
import modulecmd.system
import modulecmd.modes
import llnl.util.tty as tty

category = "utility"


def log_info(module, mode, string, **fmt_kwds):
    """Log an information message to the user

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        string (str): The informational message

    """
    modulecmd.modes.assert_known_mode(mode)
    tty.info(string.format(**fmt_kwds), reported_by=module.fullname),
import modulecmd.system
import modulecmd.modes

category = "interaction"


def prereq_any(module, mode, *names):
    """Defines prerequisites (modules that must be loaded) for this module

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        names (tuple of str): Names of prerequisite modules

    Notes:
    In load mode, asserts that at least one of the modules given by `names` is
    loaded.  Otherwise, nothing is done.

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        prereq_any('spam', 'eggs')

    If any ``spam`` or ``eggs`` is not loaded, an error occurs:

    .. code-block:: console

        $ module ls
        Currently loaded module
            1) ham

        $ module load baz
        ==> Error: One of the prerequisites 'spam,eggs' must first be loaded

    """
    # FIXME: This function should execute mc.prereq_any in any mode other than
    # unload.  In whatis, help, show, etc. modes, it should register the prereqs
    # but not enforce them.
    modulecmd.modes.assert_known_mode(mode)
    if mode == modulecmd.modes.load:
        modulecmd.system.prereq_any(*names)
import modulecmd.modes

category = "info"


def help(module, mode, help_string, **kwargs):
    """Sets a help message for `module`

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        help_string (str): Help message for the module

    Notes:
    This function sets the help string displayed by

    .. code-block:: console

        $ module help <name>

    """
    modulecmd.modes.assert_known_mode(mode)
    module.set_help_string(help_string)
import modulecmd.system
import modulecmd.modes

category = "modulepath"


def unuse(module, mode, dirname):
    """Remove the directory `dirname` from ``MODULEPATH``

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        dirname (str): Name of the directory to remove from ``MODULEPATH``

    Notes:
    In load mode, removes `dirname` from the ``MODULEPATH`` (it it is on the ``MODULEPATH``).
    In unload mode, nothing is done.

    This function potentially has side effects on the environment.  When
    a directory is ``unuse``\ d, modules in its path will become unavailable and, if
    loaded, will be unloaded.

    """
    modulecmd.modes.assert_known_mode(mode)
    if mode != modulecmd.modes.unload:
        modulecmd.system.unuse(dirname)
import modulecmd.system
import modulecmd.modes

category = "utility"


def source(module, mode, filename, *args):
    """Sources a shell script given by filename

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        filename (str): Name of the filename to source

    Notes:
    - **Warning:** This function sources a shell script unconditionally.  Environment \
            modifications made by the script are not tracked by Modulecmd.py.

    - `filename` is sourced only if ``mode()=='load'`` and is only sourced once

    """
    modulecmd.modes.assert_known_mode(mode)
    if mode == modulecmd.modes.load:
        modulecmd.system.source(filename, *args)
import modulecmd.system
import modulecmd.modes
import llnl.util.tty as tty

category = "utility"


def log_warning(module, mode, string, **fmt_kwds):
    """Log a warning message to the user

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        string (str): The warning message

    """
    modulecmd.modes.assert_known_mode(mode)
    tty.warn(string.format(**fmt_kwds), reported_by=module.fullname),
import modulecmd.system
import modulecmd.modes
import llnl.util.tty as tty

category = "utility"


def log_error(module, mode, string, **fmt_kwds):
    """Log an error message to the user to quite

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        string (str): The error message

    """
    modulecmd.modes.assert_known_mode(mode)
    tty.die(string.format(**fmt_kwds), reported_by=module.fullname),


log_error.eval_on_show = True
import modulecmd.modes
import modulecmd.environ

category = "alias"


def unset_shell_function(module, mode, name):
    """Undefine a shell function

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        name (str): Name of the shell function

    Notes:
    In unload mode, nothing is done.  Otherwise, the function given by `name` is undefined

    Examples:
    Consider the module ``baz``

    .. code-block:: python

        unset_shell_function("baz")

    .. code-block:: console

        $ declare -f baz
        baz ()
        {
            echo "I am a baz!"
        }

    On loading, the shell function ``baz`` is undefined

    .. code-block:: console

        $ module load baz
        $ declare -f baz

    """
    modulecmd.modes.assert_known_mode(mode)
    if mode != modulecmd.modes.unload:
        modulecmd.environ.unset_shell_function(name)
import modulecmd.modulepath

category = "modulepath"


def is_used(module, mode, dirname):
    """Returns whether the directory `dirname` is on the ``MODULEPATH``

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        dirname (str): Name of the directory to check

    Returns:
        is_used (bool): Wether `dirname` is on the ``MODULEPATH`` or not

    """
    modulecmd.modes.assert_known_mode(mode)
    return modulecmd.modulepath.contains(dirname)
import modulecmd.modes
import modulecmd.environ


category = "utility"


def chdir(module, mode, dirname):
    """Change directory to `dirname` after module is loaded

    Arguments:
        module (Module): The module being executed
        mode (Mode): The mode of execution
        dirname (str): The name of the directory

    """
    if mode == modulecmd.modes.load:
        modulecmd.environ.set_destination_dir(dirname)
"""This is the implementation of the module command line executable.

In a normal Modulecmd.py installation, this is invoked from a shell function
evaluating the bin/module script after the system path is set up.
"""
from __future__ import print_function

import re
import os
import sys
import inspect
import pstats
import argparse
from six import StringIO


import modulecmd.paths
import modulecmd.config
import modulecmd.modulepath
import modulecmd.environ
import modulecmd.command
import modulecmd.shell

import llnl.util.tty as tty
import llnl.util.tty.color as color
from llnl.util.tty.log import log_output
from modulecmd.util.tty import redirect_stdout


#: names of profile statistics
stat_names = pstats.Stats.sort_arg_dict_default

#: top-level aliases for modulecmd commands
aliases = {
    "av": "avail",
    "add": "load",
    "ls": "list",
    "rm": "unload",
    "which": "find",
    "cn": "collection",
}

#: help levels in order of detail (i.e., number of commands shown)
levels = ["short", "long"]

#: intro text for help at different levels
intro_by_level = {
    "short": "These are common modulecmd commands:",
    "long": "Complete list of modulecmd commands:",
}

#: control top-level modulecmd options shown in basic vs. advanced help
options_by_level = {"short": ["h", "V", "color", "dryrun"], "long": "all"}

#: Longer text for each section, to show in help
section_descriptions = {
    "info": "informational",
    "basic": "modify environment",
    "developer": "developer",
    "modulepath": "modulepath",
    "collections": "collections",
    "clones": "clones",
    "help": "more help",
}

#: preferential command order for some sections (e.g., build pipeline is
#: in execution order, not alphabetical)
section_order = {
    "info": ["avail", "list", "whatis", "show", "cat", "more", "find"],
    "basic": ["load", "unload", "reload", "swap", "purge", "refresh"],
    "modulepath": ["path", "use", "unuse"],
    "collections": ["save", "restore"],
    "clones": ["save", "restore", "remove"],
}

#: Properties that commands are required to set.
required_command_properties = ["level", "description"]

#: Recorded directory where module command was originally invoked
modulecmd_working_dir = None


def set_working_dir():
    """Change the working directory to getcwd, or modulecmd prefix if no cwd."""
    global modulecmd_working_dir
    try:
        modulecmd_working_dir = os.getcwd()
    except OSError:
        os.chdir(modulecmd.paths.prefix)
        modulecmd_working_dir = modulecmd.paths.prefix


def add_all_commands(parser):
    """Add all modulecmd subcommands to the parser."""
    for command in modulecmd.command.all_commands():
        parser.add_command(command)


def index_commands():
    """create an index of commands by section for this help level"""
    index = {}
    for command in modulecmd.command.all_commands():
        cmd_module = modulecmd.command.get_module(command)

        # make sure command modules have required properties
        for p in required_command_properties:
            prop = getattr(cmd_module, p, None)
            if not prop:
                tty.die(
                    "Command doesn't define a property {0!r}: {1}".format(p, command)
                )

        # add commands to lists for their level and higher levels
        for level in reversed(levels):
            level_sections = index.setdefault(level, {})
            commands = level_sections.setdefault(cmd_module.section, [])
            commands.append(command)
            if level == cmd_module.level:
                break

    return index


class PymodHelpFormatter(argparse.RawTextHelpFormatter):
    def _format_actions_usage(self, actions, groups):
        """Formatter with more concise usage strings."""
        usage = super(PymodHelpFormatter, self)._format_actions_usage(actions, groups)

        # compress single-character flags that are not mutually exclusive
        # at the beginning of the usage string
        chars = "".join(re.findall(r"\[-(.)\]", usage))
        usage = re.sub(r"\[-.\] ?", "", usage)
        if chars:
            return "[-%s] %s" % (chars, usage)
        else:
            return usage


class PymodArgumentParser(argparse.ArgumentParser):
    def _print_message(self, message, file=None):
        if message:
            if file is None:
                file = sys.stderr
            file.write(message)

    def format_help_sections(self, level):
        """Format help on sections for a particular verbosity level.

        Parameters
        ----------
        level : str
            'short' or 'long' (more commands shown for long)
        """
        if level not in levels:
            raise ValueError("level must be one of: %s" % levels)

        # lazily add all commands to the parser when needed.
        add_all_commands(self)

        """Print help on subcommands in neatly formatted sections."""
        formatter = self._get_formatter()

        # Create a list of subcommand actions. Argparse internals are nasty!
        # Note: you can only call _get_subactions() once.  Even nastier!
        if not hasattr(self, "actions"):
            self.actions = self._subparsers._actions[-1]._get_subactions()

        # make a set of commands not yet added.
        remaining = set(modulecmd.command.all_commands())

        def add_group(group):
            formatter.start_section(group.title)
            formatter.add_text(group.description)
            formatter.add_arguments(group._group_actions)
            formatter.end_section()

        def add_subcommand_group(title, commands):
            """Add informational help group for a specific subcommand set."""
            cmd_set = set(c for c in commands)

            # make a dict of commands of interest
            cmds = dict((a.dest, a) for a in self.actions if a.dest in cmd_set)

            # add commands to a group in order, and add the group
            group = argparse._ArgumentGroup(self, title=title)
            for name in commands:
                group._add_action(cmds[name])
                if name in remaining:
                    remaining.remove(name)
            add_group(group)

        # select only the options for the particular level we're showing.
        show_options = options_by_level[level]
        if show_options != "all":
            opts = dict(
                (opt.option_strings[0].strip("-"), opt)
                for opt in self._optionals._group_actions
            )

            new_actions = [opts[letter] for letter in show_options]
            self._optionals._group_actions = new_actions

        # custom, more concise usage for top level
        help_options = self._optionals._group_actions
        help_options = help_options + [self._positionals._group_actions[-1]]
        formatter.add_usage(self.usage, help_options, self._mutually_exclusive_groups)

        # description
        formatter.add_text(self.description)

        # start subcommands
        formatter.add_text(intro_by_level[level])

        # add argument groups based on metadata in commands
        index = index_commands()
        sections = index[level]

        for section in sorted(sections):
            if section == "help":
                continue  # Cover help in the epilog.

            group_description = section_descriptions.get(section, section)

            to_display = sections[section]
            commands = []

            # add commands whose order we care about first.
            if section in section_order:
                commands.extend(
                    cmd for cmd in section_order[section] if cmd in to_display
                )

            # add rest in alphabetical order.
            commands.extend(
                cmd for cmd in sorted(sections[section]) if cmd not in commands
            )

            # add the group to the parser
            add_subcommand_group(group_description, commands)

        # optionals
        add_group(self._optionals)

        # epilog
        formatter.add_text(
            """\
{help}:
  module help --all       list all commands and options
  module help <command>   help on a specific command""".format(
                help=section_descriptions["help"]
            )
        )

        # determine help from format above
        return formatter.format_help()

    def add_subparsers(self, **kwargs):
        """Ensure that sensible defaults are propagated to subparsers"""
        kwargs.setdefault("metavar", "SUBCOMMAND")
        sp = super(PymodArgumentParser, self).add_subparsers(**kwargs)
        old_add_parser = sp.add_parser

        def add_parser(name, **kwargs):
            kwargs.setdefault("formatter_class", PymodHelpFormatter)
            return old_add_parser(name, **kwargs)

        sp.add_parser = add_parser
        return sp

    def add_command(self, cmd_name):
        """Add one subcommand to this parser."""
        # lazily initialize any subparsers
        if not hasattr(self, "subparsers"):
            # remove the "shell" and the dummy "command" argument.
            if self._actions[-1].dest == "command":
                self._remove_action(self._actions[-1])
            self.subparsers = self.add_subparsers(metavar="COMMAND", dest="command")

        # each command module implements a parser() function, to which we
        # pass its subparser for setup.
        module = modulecmd.command.get_module(cmd_name)

        # build a list of aliases
        alias_list = [k for k, v in aliases.items() if v == cmd_name]

        subparser = self.subparsers.add_parser(
            cmd_name,
            aliases=alias_list,
            help=module.description,
            description=module.description,
        )
        module.setup_parser(subparser)

        # return the callable function for the command
        return modulecmd.command.get_command(cmd_name)

    def format_help(self, level="short"):
        if self.prog in ("modulecmd", "modulecmd.py"):
            # use format_help_sections for the main modulecmd parser, but not
            # for subparsers
            return self.format_help_sections(level)
        else:
            # in subparsers, self.prog is, e.g., 'modulecmd.py load'
            return super(PymodArgumentParser, self).format_help()


def make_argument_parser(**kwargs):
    """Create an basic argument parser without any subcommands added."""
    parser = PymodArgumentParser(
        formatter_class=PymodHelpFormatter,
        add_help=False,
        description=(
            "modulecmd - Environment modules framework implemented in Python\n\n"
            "Environment modules, or just modules, are files containing commands that,\n"
            "when processed by the module Framework, modify the current shell's\n"
            "environment.  Modules allow users to dynamically modify their environment.\n"
            "This, python, implementation of an environment module framework is inspired\n"
            "by existing frameworks written in C/TCL and Lua and seeks parity with the\n"
            "original TCL environment modules."
        ),
        **kwargs
    )

    parser.add_argument(
        "-h",
        "--help",
        dest="help",
        action="store_const",
        const="short",
        default=None,
        help="show this help message and exit",
    )
    parser.add_argument(
        "-H",
        "--all-help",
        dest="help",
        action="store_const",
        const="long",
        default=None,
        help="show help for all commands (same as modulecmd help --all)",
    )
    parser.add_argument(
        "--time", action="store_true", default=False, help="time execution of command"
    )
    parser.add_argument(
        "--verbose", action="store_true", default=False, help="print additional output"
    )
    parser.add_argument(
        "-d",
        "--debug",
        action="store_true",
        default=False,
        help="run additional debug checks",
    )
    parser.add_argument(
        "--dryrun",
        action="store_true",
        default=False,
        help="print commands to console, but do not execute them",
    )
    parser.add_argument(
        "--pdb",
        action="store_true",
        default=False,
        help="run execution through pdb debugger",
    )
    parser.add_argument(
        "--trace", action="store_true", default=False, help="trace execution of command"
    )
    parser.add_argument(
        "-V", "--version", action="store_true", help="show version number and exit"
    )
    parser.add_argument(
        "--color",
        action="store",
        default="auto",
        choices=("always", "never", "auto"),
        help="when to colorize output (default: auto)",
    )

    return parser


class PymodCommand(object):
    """Callable object that invokes a modulecmd command (for testing).

    Example usage::

        load = PymodCommand('load')
        load('module')

    Use this to invoke modulecmd commands directly from Python and check
    their output.
    """

    def __init__(self, command_name):
        """Create a new PymodCommand that invokes ``command_name`` when called.

        Args:
            command_name (str): name of the command to invoke
        """
        self.parser = make_argument_parser()
        self.command = self.parser.add_command(command_name)
        self.command_name = command_name

    def __call__(self, *argv, **kwargs):
        """Invoke this PymodCommand.

        Args:
            argv (list of str): command line arguments.

        Keyword Args:
            fail_on_error (optional bool): Don't raise an exception on error

        Returns:
            (str): combined output and error as a string

        On return, if ``fail_on_error`` is False, return value of command
        is set in ``returncode`` property, and the error is set in the
        ``error`` property.  Otherwise, raise an error.
        """
        # set these before every call to clear them out
        self.returncode = None
        self.error = None

        args, unknown = self.parser.parse_known_args([self.command_name] + list(argv))

        fail_on_error = kwargs.get("fail_on_error", True)

        out = StringIO()
        try:
            with log_output(out):
                self.returncode = _invoke_command(
                    self.command, self.parser, args, unknown
                )

        except SystemExit as e:
            self.returncode = e.code

        except BaseException as e:
            self.error = e
            if fail_on_error:
                raise

        if fail_on_error and self.returncode not in (None, 0):
            raise PymodCommandError(
                "Command exited with code %d: %s(%s)"
                % (
                    self.returncode,
                    self.command_name,
                    ", ".join("'%s'" % a for a in argv),
                )
            )

        return out.getvalue()


def setup_main_options(args):
    """Configure modulecmd globals based on the basic options."""
    # Set up environment based on args.
    tty.set_verbose(args.verbose)
    tty.set_debug(args.debug)
    #    tty.set_trace(args.trace)

    # debug must be set first so that it can even affect behavior of
    # errors raised by modulecmd.config.
    if args.debug:
        # modulecmd.error.debug = True
        modulecmd.config.set("debug", True, scope="command_line")

    if args.dryrun:
        modulecmd.config.set("dryrun", True, scope="command_line")

    if args.shell != modulecmd.config.get("default_shell"):
        modulecmd.shell.set_shell(args.shell)

    # when to use color (takes always, auto, or never)
    color.set_color_when(args.color)


def allows_unknown_args(command):
    """Implements really simple argument injection for unknown arguments.

    Commands may add an optional argument called "unknown args" to
    indicate they can handle unknonwn args, and we'll pass the unknown
    args in.
    """
    info = dict(inspect.getmembers(command))
    varnames = info["__code__"].co_varnames
    argcount = info["__code__"].co_argcount
    return argcount == 3 and varnames[2] == "unknown_args"


def _invoke_command(command, parser, args, unknown_args):
    """Run a modulecmd command *without* setting modulecmd global options."""
    if allows_unknown_args(command):
        return_val = command(parser, args, unknown_args)
    else:
        if unknown_args:
            tty.die("unrecognized arguments: {0}".format(" ".join(unknown_args)))
        return_val = command(parser, args)

    # Allow commands to return and error code if they want
    return 0 if return_val is None else return_val


def main(argv=None):
    """This is the entry point for the modulecmd command.

    Parameters
    ----------
    argv : list of str or None
        command line arguments, NOT including the executable name. If None,
        parses from sys.argv.
    """

    # Pull out the shell from argv
    argv = argv or sys.argv[1:]
    assert len(argv) >= 1
    shell = argv.pop(0)
    shells = ("bash", "csh", "python")
    if shell not in shells:
        raise ValueError("shell argument must by one of {0}".format(shells))

    # Create a parser with a simple positional argument first.  We'll
    # lazily load the subcommand(s) we need later. This allows us to
    # avoid loading all the modules from modulecmd.command when we don't need
    # them, which reduces startup latency.
    parser = make_argument_parser()
    parser.add_argument("command", nargs=argparse.REMAINDER)
    args, unknown = parser.parse_known_args(argv)
    args.shell = shell

    # Just print help and exit if run with no arguments at all
    no_args = len(argv) == 0
    if no_args:
        with redirect_stdout():
            parser.print_help()
        return 1

    # -h, -H, and -V are special as they do not require a command, but
    # all the other options do nothing without a command.
    if args.version:
        sys.stderr.write(str(modulecmd.modulecmd_version) + "\n")
        return 0
    elif args.help:
        message = parser.format_help(level=args.help)
        with redirect_stdout():
            sys.stderr.write(message)
        return 0
    elif not args.command:
        with redirect_stdout():
            parser.print_help()
        return 1

    try:
        # ensure options on modulecmd command come before everything
        setup_main_options(args)

        # Try to load the particular command the caller asked for.  If there
        # is no module for it, just die.
        cmd_name = args.command[0]
        cmd_name = aliases.get(cmd_name, cmd_name)

        try:
            command = parser.add_command(cmd_name)
        except ImportError:
            # if modulecmd.config.get('config:debug'):
            #     raise
            tty.die("Unknown command: %s" % args.command[0])

        # Re-parse with the proper sub-parser added.
        args, unknown = parser.parse_known_args(argv)

        # many operations will fail without a working directory.
        set_working_dir()

        # now we can actually execute the command.
        if args.pdb:
            import pdb

            pdb.runctx(
                "_invoke_command(command, parser, args, unknown)", globals(), locals()
            )
            return 0
        else:
            return _invoke_command(command, parser, args, unknown)

    except Exception as e:
        if modulecmd.config.get("debug"):
            raise
        tty.die(str(e))

    except KeyboardInterrupt:
        sys.stderr.write("\n")
        tty.die("Keyboard interrupt.")

    except SystemExit as e:
        return e.code


class PymodCommandError(Exception):
    """Raised when PymodCommand execution fails."""
import os
import json
from six import StringIO

import modulecmd.names
import modulecmd.paths
import modulecmd.environ

from llnl.util.lang import Singleton
from llnl.util.tty import terminal_size
from llnl.util.tty.colify import colified


class Clones(object):
    def __init__(self, filename):
        self.filename = filename
        self._data = None

    @property
    def data(self):
        if self._data is None:
            self._data = self.read(self.filename)
        return self._data

    def get(self, name):
        return self.data.get(name)

    def read(self, filename):
        if os.path.isfile(filename):
            return dict(json.load(open(filename)))
        return dict()

    def write(self, clones, filename):
        with open(filename, "w") as fh:
            json.dump(clones, fh, indent=2)

    def save(self, name):
        """Clone current environment"""
        env = modulecmd.environ.copy(include_os=True)
        self.data[name] = env
        self.write(self.data, self.filename)
        return env

    def remove(self, name):
        self.data.pop(name, None)
        self.write(self.data, self.filename)

    def avail(self, terse=False):
        names = sorted([x for x in self.data.keys()])
        if not names:  # pragma: no cover
            return ""
        sio = StringIO()
        if not terse:
            _, width = terminal_size()
            s = colified(names, width=width)
            sio.write("{0}\n{1}\n".format(" Saved clones ".center(width, "-"), s))
        else:
            sio.write("\n".join(c for c in names))
        return sio.getvalue()


def factory():
    basename = modulecmd.names.clones_file_basename
    filename = modulecmd.paths.join_user(basename, cache=True)
    return Clones(filename)


clones = Singleton(factory)


def save(name):
    return clones.save(name)


def remove(name):
    clones.remove(name)


def avail(terse=False):
    return clones.avail(terse)


def get(name):
    return clones.get(name)
import os
import sys
from argparse import Namespace

import modulecmd.names
import modulecmd.shell
import modulecmd.modulepath

from modulecmd.serialize import serialize, deserialize
from modulecmd.serialize import serialize_chunked, deserialize_chunked
from modulecmd.util.lang import join, split, pop, get_system_manpath

import llnl.util.tty as tty
from llnl.util.lang import Singleton


class Environ(dict):
    def __init__(self):
        self.aliases = {}
        self.shell_functions = {}
        self.destination_dir = None
        self._sys_manpath = None
        self.files_to_source = []
        self.raw_shell_commands = []

    def __getitem__(self, key):
        """Overload Environ[] to first check me, then os.environ"""
        if key in self:
            return super(Environ, self).__getitem__(key)
        return os.environ[key]

    def is_empty(self):
        return not len(self) and not len(self.aliases) and not len(self.shell_functions)

    def format_output(self):
        env = self.copy()
        output = modulecmd.shell.format_output(
            env,
            aliases=self.aliases,
            shell_functions=self.shell_functions,
            files_to_source=self.files_to_source,
            raw_shell_commands=self.raw_shell_commands
        )
        if self.destination_dir is not None:
            output += "cd {0};".format(self.destination_dir)
        return output

    def set_destination_dir(self, dirname):
        if not os.path.isdir(dirname):
            tty.die("{0} is not a directory".format(dirname))
        self.destination_dir = dirname

    def get(self, key, default=None, type=None):
        """Overload Environ.get to first check me, then os.environ"""
        val = super(Environ, self).get(key, os.getenv(key, default))
        return val if type is None else type(val)

    def get_path(self, key, sep=os.pathsep):
        """Get the path given by `key`

        When paths are saved, the path value is saved and also some meta data.
        Currently, the saved meta data are the reference count and priority,
        though priority is not yet used.

        The meta data are saved in a dictionary in the environment variable
        `loaded_module_meta(key)`

        """
        p = Namespace()
        p.key = self.fix_ld_library_path(key)
        p.meta_key = modulecmd.names.loaded_module_meta(key)
        p.sep = sep
        p.value = split(self.get(key), sep=sep)
        serialized = self.get(p.meta_key)
        p.meta = {} if serialized is None else deserialize(serialized)
        return p

    def set_path(self, path):
        if not path.value:
            self[path.key] = None
            self[path.meta_key] = None
        else:
            self[path.key] = join(path.value, path.sep)
            self[path.meta_key] = serialize(path.meta)
        self.save_ld_library_path(path.key)

    def filtered(self, include_os=False):
        return self.copy(include_os=include_os, filter_None=True)

    def clone(self):
        return {
            "aliases": self.aliases.copy(),
            "shell_functions": self.shell_functions.copy(),
            "env": self.copy(),
        }

    def restore(self, clone):
        self.aliases = clone["aliases"]
        self.shell_functions = clone["shell_functions"]
        for key in list(self.keys()):
            del self[key]
        self.update(clone["env"])

    def copy(self, include_os=False, filter_None=False):
        env = dict(os.environ) if include_os else dict()
        if filter_None:
            env.update(dict([item for item in self.items() if item[1] is not None]))
        else:
            env.update(self)

        # Modulepath is a special case
        mp = modulecmd.modulepath._path.value
        if include_os:
            env[modulecmd.names.modulepath] = mp
        elif mp != os.getenv(modulecmd.names.modulepath):
            env[modulecmd.names.modulepath] = mp

        modulecmd_env = dict()
        for (key, val) in env.items():
            if modulecmd.shell.filter_key(key):
                continue
            modulecmd_env[key] = val

        return modulecmd_env

    @staticmethod
    def fix_ld_library_path(key):
        if key == modulecmd.names.ld_library_path:
            key = modulecmd.names.platform_ld_library_path
        return key

    @property
    def sys_manpath(self):  # pragma: no cover
        if self._sys_manpath is None:
            self._sys_manpath = get_system_manpath()
        return self._sys_manpath

    def set_manpath_if_needed(self):  # pragma: no cover
        if sys.platform == "darwin" and not self.get(modulecmd.names.manpath):
            # On macOS, MANPATH, if set, must also include system paths,
            # otherwise man will not search the system paths (it only searches
            # MANPATH)
            self.set(modulecmd.names.manpath, self.sys_manpath)

    def unset_manpath_if_needed(self, path):  # pragma: no cover
        assert path.key == modulecmd.names.manpath
        if sys.platform == "darwin":
            cur_manpath = join(path.value, sep=os.pathsep)
            if cur_manpath == self.sys_manpath:
                path.value = None

    def save_ld_library_path(self, key):
        if key.endswith(modulecmd.names.ld_library_path):
            # sometimes python doesn't pick up ld_library_path :(
            self["__{0}__".format(key)] = self[key]

    def set(self, key, value):
        if key == modulecmd.names.modulepath:
            raise ValueError(
                "Do not set MODULEPATH directly in Environ object.  "
                "Set it in the Modulepath instead"
            )
        key = self.fix_ld_library_path(key)
        self[key] = value
        self.save_ld_library_path(key)

    def unset(self, key):
        if key == modulecmd.names.modulepath:
            raise ValueError(
                "Do not set MODULEPATH directly in Environ object.  "
                "Unset it in the Modulepath instead"
            )
        key = self.fix_ld_library_path(key)
        self[key] = None
        self.save_ld_library_path(key)

    def set_alias(self, key, value):
        self.aliases[key] = value

    def unset_alias(self, key):
        self.aliases[key] = None

    def set_shell_function(self, key, value):
        self.shell_functions[key] = value

    def unset_shell_function(self, key):
        self.shell_functions[key] = None

    def append_path(self, key, value, sep=os.pathsep):
        if key == modulecmd.names.manpath:  # pragma: no cover
            self.set_manpath_if_needed()
        elif key == modulecmd.names.modulepath:
            raise ValueError(
                "Do not set MODULEPATH directly in Environ object.  "
                "Set it in the Modulepath instead"
            )
        key = self.fix_ld_library_path(key)
        allow_dups = modulecmd.config.get("allow_duplicate_path_entries")
        current_path = self.get_path(key, sep=sep)
        d = current_path.meta.pop(value, {"count": 0, "priority": -1})
        if d["count"] == 0 and value in current_path.value:
            d["count"] = current_path.value.count(value)
        d["count"] += 1
        if allow_dups or value not in current_path.value:
            current_path.value.append(value)
        current_path.meta[value] = d
        self.set_path(current_path)

    def prepend_path(self, key, value, sep=os.pathsep):
        if key == modulecmd.names.manpath:  # pragma: no cover
            self.set_manpath_if_needed()
        elif key == modulecmd.names.modulepath:
            raise ValueError(
                "Do not set MODULEPATH directly in Environ object.  "
                "Set it in the Modulepath instead"
            )
        key = self.fix_ld_library_path(key)
        allow_dups = modulecmd.config.get("allow_duplicate_path_entries")
        current_path = self.get_path(key, sep=sep)
        d = current_path.meta.pop(value, {"count": 0, "priority": -1})
        if d["count"] == 0 and value in current_path.value:
            d["count"] = current_path.value.count(value)
        d["count"] += 1
        if not allow_dups:
            pop(current_path.value, value)
        current_path.value.insert(0, value)
        current_path.meta[value] = d
        self.set_path(current_path)

    def remove_path(self, key, value, sep=os.pathsep):
        if key == modulecmd.names.modulepath:
            raise ValueError(
                "Do not remove MODULEPATH directly from Environ object.  "
                "Use the Modulepath object instead"
            )
        key = self.fix_ld_library_path(key)
        allow_dups = modulecmd.config.get("allow_duplicate_path_entries")
        current_path = self.get_path(key, sep=sep)
        d = current_path.meta.pop(value, {"count": 0, "priority": -1})
        if d["count"] == 0 and value in current_path.value:  # pragma: no cover
            tty.warn("Inconsistent refcount state")
            d["count"] = current_path.value.count(value)
            if modulecmd.config.get("debug"):
                raise Exception("Inconsistent refcount state")
        d["count"] -= 1
        if (allow_dups and d["count"] > 0) or d["count"] <= 0:
            pop(current_path.value, value)
        if d["count"] > 0:
            current_path.meta[value] = d
        if key == modulecmd.names.manpath:  # pragma: no cover
            self.unset_manpath_if_needed(current_path)
        self.set_path(current_path)

    def source_file(self, filename, *args):
        self.files_to_source.append((filename, args))

    def raw_shell_command(self, command):
        self.raw_shell_commands.append(command)


def factory():
    return Environ()


environ = Singleton(factory)


def set_env(env):
    global environ
    environ = env


def is_empty():
    return environ.is_empty()


def format_output():
    return environ.format_output()


def get(key, default=None, serialized=False, type=None):
    if serialized:
        return _get_and_deserialize(environ, key, default=default)
    return environ.get(key, default, type=type)


def set(key, value, serialize=False):
    if serialize:
        return _serialize_and_set(environ, key, value)
    return environ.set(key, value)


def unset(key):
    return environ.unset(key)


def set_alias(key, value):
    return environ.set_alias(key, value)


def unset_alias(key):
    return environ.unset_alias(key)


def set_shell_function(key, value):
    return environ.set_shell_function(key, value)


def unset_shell_function(key):
    return environ.unset_shell_function(key)


def append_path(key, value, sep=os.pathsep):
    return environ.append_path(key, value, sep)


def prepend_path(key, value, sep=os.pathsep):
    return environ.prepend_path(key, value, sep)


def remove_path(key, value, sep=os.pathsep):
    return environ.remove_path(key, value, sep)


def get_path(key, sep=os.pathsep):
    return split(environ.get(key), sep=sep)


def set_path(key, path, sep=os.pathsep):
    value = join(path, sep=sep)
    return environ.set(key, value)


def _serialize_and_set(container, label, value):

    # Reset previously set values
    for (key, item) in os.environ.items():
        if key.startswith(label):
            container.set(key, None)

    # Serialize the
    if value is None:
        key = modulecmd.names.serialized_key(label, 0)
        container.set(key, None)
        return

    serialized = serialize_chunked(value)
    for (i, chunk) in enumerate(serialized):
        key = modulecmd.names.serialized_key(label, i)
        container.set(key, chunk)


def _get_and_deserialize(container, label, default=None):
    i = 0
    chunks = []
    while True:
        key = modulecmd.names.serialized_key(label, i)
        try:
            chunk = container[key]
        except KeyError:
            break
        if chunk is None:
            return None
        chunks.append(chunk)
        i += 1
    if not chunks:
        return default
    return deserialize_chunked(chunks)


def filtered(include_os=False):
    return environ.filtered(include_os=include_os)


def copy(include_os=False):
    return environ.copy(include_os=include_os)


def clone():
    return environ.clone()


def restore(the_clone):
    return environ.restore(the_clone)


def set_destination_dir(dirname):
    environ.set_destination_dir(dirname)


def source_file(filename, *args):
    environ.source_file(filename, *args)


def raw_shell_command(command):
    environ.raw_shell_command(command)
