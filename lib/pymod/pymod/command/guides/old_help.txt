@*{NAME}

  module - Environment modules framework implemented in Python

@*{SYNOPSIS}

  module [--version] [-h|--help] [--profile] [--time] <command> [<args>]

@*{DESCRIPTION}

  Environment modules, or just modules, are files containing commands that,
  when processed by the module Framework, modify the current shell's
  environment.  Modules allow users to dynamically modify their environment.
  This, python, implementation of an environment module framework is inspired
  by existing frameworks written in C/TCL and Lua and seeks parity with the
  original TCL environment modules.

@*{OPTIONS}

  --version
    Show program's version number and exit.
  --help
    If a module command is named, shows the help message for that command,
    otherwise, show this help message and exit.
  --profile
    Run command in Python profiler.
  --time
    Time the module execution.

@*{MODULE COMMANDS}

  avail [regex] [--terse] ['-F']
    Displays available modules.  @_{regex} is a regular expression highlighted
    in the output.

    With the @_{--terse} option, output will be displayed in terse format.

    With the @_{-F} option, full output will be displayed, including nonexistent
    and empty directories.

  cat <name>
    print @_{name} to the console output.  @_{name} can be the name of a
    module, collection, or one of @`{avail} or @`{collections}.

  edit <name>
    Open module @_{name}'s file in EDITOR for editing.

  file <module> [module...]
    Show the file path[s] to @_{module [...]}.

  init [--mp=MP]
    Initialize the module command.  This command is a shortcut for calling

      module use <PATH1>
      module use <PATH2>
      ...
      module use <PATHN>
      module restore default

  list (l) [regex] [--terse] [--show-command] [-c]
    Displays loaded modules.  @_{regex} is a regular expression highlighted
    in the output.

    With the @_{--terse} option, output is displayed in terse format.
    With the @_{--show-command} or @_{-c} option, output displays load commands

  load (add) <name> [name...] [-x] [--insert-at <i>] [options]
  unload (rm) <name> [name...]
  reload <name> [name...]
    Load, unload, or reload the module[s] @_{name [name...]}

    With the @_{-x} option, the module will not be added to the list of loaded modules.

    With the @_{--insert-at <i>} option, the module will be loaded as the @`{i}th module.

    Additional options can be sent directly to the module using the syntax,
    @_{+option[=value]}.  See the section on module options for more details.

  more <name>
    print @_{name} to the console output on page at a time.  Allows movement
    through files similar to shell's @`{less} program.  @_{name} can be the name
    of a module, collection, or one of @`{avail} or @`{collections}.

  path
    Show the module path

  purge [-F]
    Unload all loaded modules

    With the @_{-F} option, no modules will be loaded after purging, even if the variable
    load_after_purge is set in the rc file.

  refresh
    Refresh (unload/reload) all modules

  show <name> [name...]
    Show the commands in the module file[s].

  swap <name_a> <name_b>
    Unload module @_{name_a} and load @_{name_b} in its place

  test
    Run module tests (requires pytest module)

  use <path> [path...]
  use -D <path> [path...]
  unuse <path> [path...]
    Add (use) or remove (unuse) directory[s] to/from MODULEPATH

    With the @_{-D} option, @`{use} behaves exactly as @`{unuse}.

  whatis
    Display module whatis string.  The whatis string is a short informational
    message a module can provide.  If not defined by the module, a default is
    displayed.

@*{MODULE COLLECTION COMMANDS}

  collection save [name|-f name]
  collection restore <name>
  collection avail
  collection show <name>
  collection rm <name>
    Save, restore, list, display, or remove a collection of modules.

    Module collections are collections of modules that can be restored (loaded)
    with a single command.

    The subcommand @`{save} saves the currently loaded modules to the collection
     @_{name}, if @_{name} is supplied; if @_{-f name} is supplied, the collection
    is saved to a file named @_{name}.collection in the current working directory;
    otherwise, the modules are saved to the     user's default collection.

    @`{restore} loads the modules saved to collection @_{name} after unloading
    any loaded modules.  If @_{name} is not supplied, the user's default
    collection is restored.  If @_{name} is a file, the collection is loaded from
    the file.

    @`{avail} lists saved collections.

    @`{show} shows the contents of the module collection @_{name}.

    @`{rm} removes collection @_{name} from the list of collections.

@*{MODULE CLONE COMMANDS}

  clone save <name>
  clone restore <name>
  clone avail
  clone rm <name>
    Save, restore, list, display, or remove a clone of the environment.

@*{MODULE COMMANDS THAT MODIFY THE ENVIRONMENT DIRECTLY}
Shell aliases and environment variables can be set directly by module.

  shell alias [name[=value]]
  shell alias -D <name>
    List, create, remove shell aliases.  Shell aliases allow a string to be
    substituted for shell commands.

    If arguments are supplied, an @`{shell alias} is defined for the @_{name} whose
    @_{value} is given.  If no @_{value} is given, @`{shell alias} will print
    the current value of the alias.

    Without arguments, @`{shell alias} prints the list of a shell aliases.

    With the @_{-D} option, @_{name} will be deleted from the list of defined
    aliases.

  shell env <name[=value]>
  shell env -D <name>
    List, create, remove environment variables.

    @`{shell env}: An environment variable is defined for the @_{name} whose
    @_{value}
    is given.  If no @_{value} is given, @`{shell env} will print the current
    value of the environment variable.

    With the @_{-D} option, @_{name} will be unset from the environment.

@*{USER ENVIRONMENT FILE}

The user environment file PYMOD_DOT_DIR/module.env is used to configure the
behavior of pymod on a per-user basis.  The pymod environment file uses Python
syntax.

The following parameters are read from the environment file:

The environment file is imported by pymod and is made available to modules
executed by pymod as the 'user_env' object.  e.g., if the function 'baz' were
defined in a users module.env file, that function would be available as
'user_env.baz' in any module executed by pymod.

@*{ENVIRONMENT VARIABLES}

pymod uses the following environment variables:

LOADEDMODULES
  A colon separated list of all loaded modulefiles.

MODULEPATH
  The path that the module command searches when looking for modulefiles.
  MODULEPATH can be set directly in a shell startup script or using @`{module use}.

_LMFILES_
  A colon separated list of the full pathname for all loaded modulefiles.

_LMOPTS_
  A list of set options for all loaded modules.

_LMREFCNT_<PATH>
  A reference count for all path-like variables.

PYMOD_DOT_DIR
  If the PYMOD_DOT_DIR environment variable is set then it specifies a path to
  use instead of the default (~/.pymod).  PYMOD_DOT_DIR is used by pymod to
  write internally used data.  It is also the directory where the user
  environment file is looked for.

@*{MODULEFILES}

pymod module files are python files that are executed by the pymod Framework.
Modulefiles must have a .py file extension and be on the MODULEPATH to be
recognized.  pymod executes module files in an environment providing the
following commands:

@_{GENERAL PURPOSE}
  @`{getenv(name)}
    Get the value of environment variable given by name.  Returns None if name
    is not defined.
  @`{get_hostname()}
    Get the value of the host name of the sytem.
  @`{mode()}
    Return the active mode.  One of "load" or "unload"
  @`{self}
    Reference to this modules object.
  @`{HOME}
    The path to HOME
  @`{USER}
    The name of USER
  @`{IS_DARWIN}
    Boolean.  True if the system is Darwin.  False otherwise.
  @`{user_env}
    Reference to a user defined Python module containing custom commands.
  @`{args}
    List of commands passed from command line to this module.

@_{MESSAGE LOGGING}
  @`{log_message(message)}
    Log an informational message to the console.
  @`{log_info(message)}
    Log an informational message to the console.
  @`{log_warning(message)}
    Log a warning message to the console.
  @`{log_error(message)}
    Log an error message to the console and quit.

@_{ENVIRONMENT MODIFICATION}
  @`{setenv(variable, value)}
    Set the environment variable variable to value.
  @`{unsetenv(variable)}
    Unset the environment variable variable.
  @`{set_alias(name, value)}
    Set the alias name to value.
  @`{unset_alias(name)}
    Unset the alias given by name.

  @`{set_shell_function(name, value)}
    Set the shell function name to value.
  @`{unset_shell_function(name, value)}
    Unset the shell function name

  @`{prepend_path(pathname, value)}
    Prepend value to path-like variable pathname.
  @`{append_path(pathname, value)}
    Append value to path-like variable pathname.
  @`{remove_path(pathname, value)}
    Remove value from path-like variable pathname.

@_{INTERACTION WITH OTHER MODULES}
  @`{prereq(name)}
    Module name is a prerequisite of this module.
    If name is not loaded, pymod will quit.
  @`{prereq_any(*names)}
    Any one of names is a prerequisite of this module.
    If none of names is not loaded, pymod will quit.
  @`{conflict(*names)}
    Module name is a prerequisite of this module.
    If name is not loaded, pymod will quit.
  @`{load(name)}
    Load the module name.
  @`{load_first(*names)}
    Load the first module in names.
  @`{unload(name)}
    Unload the module name.

@_{MODULE OPTIONS}
A module can support command line options.  Options are specified on the
commandline as

    @`{module load <modulename> [+option[=value] [+option...]]}

The following modulefile functions register options

  @`{add_option(name, action='store_true')}
    Register a module option.  By default, options are boolean flags.  Pass
    @`{action='store'} to register an option that takes a value.

  @`{add_mutually_exclusive_option(name1, name2, action='store_true')}
    Register a mutually exclusive option

  @`{parse_opts}
    Parse module options.  Only options added before calling @`{parse_opts} will
    be parsed.

@`{EXAMPLE}
To specify two options for module 'spam', in modulefile spam.py do

  add_option('+x', action='store')  # option with value
  add_option('+b')  # boolean option
  opts = parse_opts()

  if (opts.b):
      # Do something
  if (opts.x == 'baz'):
      # Do something

On the commandline, the module spam can be loaded as

  @`{module load spam +b +x=baz}

@_{OTHER COMMANDS}
  @`{family(name)}
    Set the name of the module's family.
  @`{execute(command)}
    Execute command in the current shell.
  @`{whatis(string)}
    Store string as an informational message describing this module.

@_{EXAMPLE}
The following commands, when put in a module file on MODULEPATH, prepends the
user's bin directory to the PATH and aliases the ls command.

  prepend_path('PATH', '~/bin')
  set_alias('ls', 'ls -lF')
